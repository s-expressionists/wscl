<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp â€” DECLARATION-SCOPE</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">DECLARATION-SCOPE</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem description">Problem description</a><ol> </ol></li><li><a href="#issue-declaration-scope:no-hoisting">Proposal NO-HOISTING</a><ol> </ol></li><li><a href="#issue-declaration-scope:limited-hoisting">Proposal LIMITED-HOISTING</a><ol> </ol></li><li><a href="#section-Examples">Examples</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current practice">Current practice</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of non-adoption">Cost of non-adoption</a><ol> </ol></li><li><a href="#section-Performance impact">Performance impact</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Esthetics">Esthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue DECLARATION-SCOPE [NIL] [CHANGE/CLARIFICATION]</h1><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>Proposal <a class="proposal-reference" href="#issue-declaration-scope:no-hoisting">NO-HOISTING</a> passed Jan 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>Declaration Syntax (CLtL, Section 9.1, pp. 153-157) LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66) Cleanup <a class="issue-reference" href="../issues/flet-declarations.xhtml#issue-flet-declarations">X3J13 Issue FLET-DECLARATIONS</a> (accepted) Cleanup <span class="issue-reference error">issue:Issue DECLARE-TYPE-FREE</span> (accepted) </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>V1: Hornig@Symbolics.COM &ndash; 5 January 1988 Version 2, Moon, 2-Feb-1988 (edits based on discussion) Version 3, Moon, 18-Sep-88, for private discussion between JonL and Moon Version 4, JonL, 15-Nov-88 add 2nd proposal; major rewrite. <br/></section><section id="section-Problem description" class="section"><h2 class="section-title">Problem description</h2>The description of the scope of declarations made with <a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> is  unclear <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">although</span> <span class="syntax-interned-symbol">unambiguous</span>)</span>
</span></code></pre> and arguably a mistake.  At issue is whether the scope of some or all of the declarations at the head of a special form includes code appearing in any non-body part of that  special form.  CLtL p.155 attempts to address the issue by classifying  declarations into two classes &ndash; "pervasive" and "non-pervasive" &ndash; but  it does not succeed very well. <br/>A particular question of interest is whether the initial value forms for  <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-flet">flet</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-labels">labels</a>, <a class="macro-reference" href="../chapter-6.xhtml#macro-do">do</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-prog">prog</a> etc. are included.  The rules of CLtL, on some cases, are clear enough to see that a declaration inside the  special form is "hoisted" up and around the whole form, so as to include  all the "initial value" forms <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-string">"stepper"</span> <span class="syntax-interned-symbol">forms</span> <a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-string">"result"</span> <span class="syntax-interned-symbol">forms</span> <span class="syntax-interned-symbol">for</span> 
<span class="syntax-interned-symbol">those</span> <span class="syntax-interned-symbol">constructs</span> <span class="syntax-interned-symbol">that</span> <span class="syntax-interned-symbol">have</span> <span class="syntax-interned-symbol">them</span>)</span>
</span></code></pre>.  This means that lexical argument  variable X in the following function is inaccessible inside the initial  value forms of the <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a>:   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">bar</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>	    <span class="syntax-line-comment syntax-comment">;[1] 1st instance of x
</span>    <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>	    <span class="syntax-line-comment syntax-comment">;[2] 2nd instance of x &ndash; same as 1st instance?
</span>	  <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>)</span>	    <span class="syntax-line-comment syntax-comment">;[3] 3rd instance
</span>      <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
      <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>)</span>
</span></code></pre> The declaration intended for the binding of X[3] also alters the scoping of the reference of X[2]; likely, this was not an intended  consequence. [This is a simplification of the example on CLtL p.155]. <br/>In this discussion, the term "body" will include any "stepper" or  "result" forms, such as might be found in a <a class="macro-reference" href="../chapter-6.xhtml#macro-do">do</a> or DO-mumble-SYMBOLS construct.  The reasoning for this is that such forms are always  included in the scope of all name bindings <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-if">if</a> <span class="syntax-interned-symbol">any</span>)</span>
</span></code></pre> being established  by the special form.  They form an extended part of the "body". <br/><br/></section><section class="status-passed proposal" id="issue-declaration-scope:no-hoisting"><h2 class="section-title">Proposal NO-HOISTING</h2>Specify that the scope of a declaration located at the head of a special  form or lambda expression is as follows: <ol><li> it always includes the body forms [as well as any "stepper" or   "result" forms] </li><li> it also includes the scope of the name binding, if any, to which   it applies [<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a>, <a class="macro-reference" href="../chapter-3.xhtml#macro-lambda">lambda</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-flet">flet</a>, <a class="macro-reference" href="../chapter-6.xhtml#macro-do">do</a>, etc. introduce "name bindings";   <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-locally">locally</a> doesn't.]; <br/></li></ol>This very straightforward prescription depends on one rather subtle point, namely that the scope of name bindings is an already solved question.  Whether or not a particular declaration affects an initial value form <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">such</span> <span class="syntax-interned-symbol">as</span> <span class="syntax-interned-symbol">for</span> <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a>)</span>
</span></code></pre> depends _solely_ on whether it is applied to a variable or function <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">name</span>)</span>
</span></code></pre> being bound whose scope includes such forms.  In this sense, the above specification limits the scope of declarations for name bindings to be exactly the scope of the name binding itself &ndash; i.e. "like variable".  Thus there would be no "hoisting" of the special declarations in the example cited in the problem description.  [See the Discussion section for a review of the  <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> rules on variable/function-name scoping in special forms.] <br/>Those declarations not correlated with any name binding do not cover any of the initial-value forms; their scope simply includes the body <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">as</span> <span class="syntax-interned-symbol">well</span> 
<span class="syntax-interned-symbol">as</span> <span class="syntax-interned-symbol">any</span> <span class="syntax-string">"stepper"</span> <a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-string">"result"</span> <span class="syntax-interned-symbol">forms</span>)</span>
</span></code></pre>.  In a sense, the above specification  limits the scope of these kinds of declarations to be the same as an arbitrary name binding in a <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> or <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-flet">flet</a> construct &ndash; i.e. "like variable". [See also the <span class="issue-reference error">issue:Issue DECLARE-TYPE-FREE.</span>] <br/>Thus there is to be no "hoisting" for declarations in special forms or  lambda expressions; the only initial value forms affected by a declaration  will be those included indirectly, by the effect, if any, that a  declaration has on a name binding.  <br/>A question may arise as to what it means for a declaration to "apply to",  or "be correlated to" a name binding.  As stated above about variable scoping, this is an already solved question in Common Lisp; it is not  the purpose of this proposal to alter, clarify or in any other way bear  upon the basic _applicability_ rules of declarations in Common Lisp.   However, a few reminders about these rules will help one understand the  above specification:   &ndash;  <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> and <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a> declarations never apply to function bindings;   &ndash;  <a class="declaration-reference" href="../chapter-3.xhtml#declaration-inline">inline</a> and <a class="declaration-reference" href="../chapter-3.xhtml#declaration-ftype">ftype</a> declarations never apply to variable bindings;    &ndash;  <a class="declaration-reference" href="../chapter-3.xhtml#declaration-optimize">optimize</a> never applies to either kind of binding;   &ndash;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">&lt;declaration&gt;</span> <span class="syntax-interned-symbol">X</span>)</span>
</span></code></pre> never applies to a binding of Y. The specific rules are for the most part distributed throughout the  individual declaration definitions.  The name-applicibility issue for  bindings must be specified independently of how the declaration scoping  issue is decided, and should not be confused with that scoping issue. <br/><br/></section><section class="status-unknown proposal" id="issue-declaration-scope:limited-hoisting"><h2 class="section-title">Proposal LIMITED-HOISTING</h2>Specify that the scope of a declaration located at the head of a special  form or lambda expression is as follows: <ol><li> it always includes the body forms [as well as any "stepper" or   "result" forms] </li><li> if the declaration is applicable to a name binding in that form,  then it is limited to exactly the scope of that name binding [<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a>,   <a class="macro-reference" href="../chapter-3.xhtml#macro-lambda">lambda</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-flet">flet</a>, etc. introduce "name bindings"; <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-locally">locally</a> doesn't.]; </li><li> if the declaration is not applicable to a name binding in that form,  then it includes all the initial value forms, in addition to the  body forms. <br/></li></ol>This very straightforward prescription depends on one rather subtle  point, namely that the scope of name bindings is an already solved  question.  This applies not only to <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> and <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a> variables, but to the  &amp;optional, &amp;key and &amp;aux variables of LAMBDA-Expressions.  In this sense,  the above specification limits the scope of declarations for name bindings  to be exactly the scope of the name binding itself.  Thus there would be  no "hoisting" of the special declarations in the example cited in the problem description. <br/>Those declarations not correlated with any name binding act as if they were included in a new <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-locally">locally</a> construct wrapped around the entire special form.  Thus they are not scoped like an arbitrary variable (or, "name binding") in that special form, but rather are "hoisted" up. <br/>Whether or not a declaration is "hoisted" up around the special form in  which it occurs depends on whether or not it is "captured en passant" by  a correlated name binding. <br/>A question may arise as to what it means for a declaration to "apply to",  or "be correlated to" a name binding.  As stated above about variable scoping, this is an already solved question in Common Lisp; it is not  the purpose of this proposal to alter, clarify or in any other way bear  upon the basic _applicability_ rules of declarations in Common Lisp.   However, a few reminders about these rules will help one understand the  above specification:   &ndash;  <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> and <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a> declarations never apply to function bindings;   &ndash;  <a class="declaration-reference" href="../chapter-3.xhtml#declaration-inline">inline</a> and <a class="declaration-reference" href="../chapter-3.xhtml#declaration-ftype">ftype</a> declarations never apply to variable bindings;    &ndash;  <a class="declaration-reference" href="../chapter-3.xhtml#declaration-optimize">optimize</a> never applies to either kind of binding;   &ndash;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">&lt;declaration&gt;</span> <span class="syntax-interned-symbol">X</span>)</span>
</span></code></pre> never applies to a binding of Y. The specific rules are for the most part distributed throughout the  individual declaration definitions.  The name-applicibility issue for  bindings must be specified independently of how the declaration scoping  issue is decided, and should not be confused with that scoping issue. <br/></section><section id="section-Examples" class="section"><h2 class="section-title">Examples</h2><pre>;;; The following example is from a <a class="package-reference" href="../chapter-1.xhtml#package-common-lisp">common-lisp</a> mailing list discussion<br/>;;;  (from code suggested by Pavel Curtis).   The question is whether or<br/>;;;  not the special declaration in <a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a> applies to the  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-1+">1+</a> <span class="syntax-interned-symbol">x</span>)</span>
</span></code></pre> form.<br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-10.xhtml#function-symbol-value">symbol-value</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">x</span></span>)</span> <span class="syntax-number">6</span>)</span>
</span></code></pre><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">foo</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span>)</span>				<span class="syntax-line-comment syntax-comment">;a lexical binding of X
</span>  <span class="syntax-cons">(<a class="function-reference" href="../chapter-22.xhtml#function-print">print</a> <span class="syntax-interned-symbol">x</span>)</span>
  <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-1+">1+</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>)</span>			<span class="syntax-line-comment syntax-comment">;is the second X special or not?
</span>    <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>		<span class="syntax-line-comment syntax-comment">;`normal' declaration
</span>    <span class="syntax-cons">(<span class="syntax-interned-symbol">bar</span>)</span>)</span>
  <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-1+">1+</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
</span></code></pre><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">bar</span> <span class="syntax-symbol">()</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-22.xhtml#function-print">print</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-locally">locally</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>)</span>
</span></code></pre><br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">foo</span> <span class="syntax-number">10</span>)</span>
</span></code></pre>  will  printout of 10 and 11 by either proposal herein<br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">foo</span> <span class="syntax-number">10</span>)</span>
</span></code></pre>  will  printout of 10 and 7 by CLtL style "hoisting"<br/><br/>;;; The following example is due to Jim Boyce, of Lucid Inc.  It shows how<br/>;;;  the "hoisting" of the declaration inadvertently causes it to act more<br/>;;;  like a proclamation than a declaration; namely, the declaration is<br/>;;;  applied to two different variables (which happen to have the same<br/>;;;  name) &ndash; the first variable is the lexical one bound on line [1] and<br/>;;;  the second variables is bound on line [3].  Whereas lexical scoping<br/>;;;  rules would say that the reference in line [2] is to the variable<br/>;;;  bound on line [1], the effect of the "hoisted" declaration is to<br/>;;;  make the line [1]'s variable inaccessible in the initial value forms.<br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-10.xhtml#function-symbol-value">symbol-value</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">x</span></span>)</span> <span class="syntax-number">6</span>)</span>
</span></code></pre><br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">bar</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>	    <span class="syntax-line-comment syntax-comment">;[1] 1st instance of x
</span>  <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>	    <span class="syntax-line-comment syntax-comment">;[2] 2nd instance of x &ndash; same as 1st instance?
</span>        <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>)</span>		    <span class="syntax-line-comment syntax-comment">;[3] 3rd instance
</span>    <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
    <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>)</span>
</span></code></pre><br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">bar</span> <span class="syntax-quote">'<a class="function-reference" href="../chapter-14.xhtml#function-first">first</a></span> <span class="syntax-quote">'<a class="function-reference" href="../chapter-14.xhtml#function-second">second</a></span>)</span>
</span></code></pre>	==&gt;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-first">first</a> <a class="function-reference" href="../chapter-14.xhtml#function-second">second</a>)</span>
</span></code></pre>    ;by either proposal herein<br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">bar</span> <span class="syntax-quote">'<a class="function-reference" href="../chapter-14.xhtml#function-first">first</a></span> <span class="syntax-quote">'<a class="function-reference" href="../chapter-14.xhtml#function-second">second</a></span>)</span>
</span></code></pre>	==&gt;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-number">6</span> <a class="function-reference" href="../chapter-14.xhtml#function-second">second</a>)</span>
</span></code></pre>        ;by "hoisting", a la CLtL.<br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>These semantics are simpler to understand.  Almost everyone feels that the example of CLtL p.155 is very unnatural.  <a class="proposal-reference" href="#issue-declaration-scope:limited-hoisting">LIMITED-HOISTING</a> is less  of a change to CLtL semantics; but <a class="proposal-reference" href="#issue-declaration-scope:no-hoisting">NO-HOISTING</a> seems more natural to  most people since it restores a closer equivalence between <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> forms  and LAMBDA-expressions.  Also, several vendors report that customers  frequently seem to assume the semantics of <a class="proposal-reference" href="#issue-declaration-scope:no-hoisting">NO-HOISTING</a>. <br/></section><section id="section-Current practice" class="section"><h2 class="section-title">Current practice</h2>Most implementations implement the rules in CLtL, as exemplified by the example on p.155.  Symbolics currently implements rules based on Zetalisp which are different from both this proposal and Common Lisp. Symbolics plans to change to Common Lisp rules in the future. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>Modest; some minor fixes will be necessary to to compilers, interpreters  and "code walkers" that parse declarations. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>Modest.  It is mostly moot since users tend to avoid the "hoisting" situations on special declarations. <br/>It is possible to mechanically examine a program to determine whether its behavior would change under the new rules.  This permits an implementation to provide a transition tool to ease conversion to the new definition. <br/></section><section id="section-Cost of non-adoption" class="section"><h2 class="section-title">Cost of non-adoption</h2>Serious non-portability of code, since not every implementor seems to  agree on how to read the disputed rules of CLtL pp. 153-157; continuing confusion in the user community. <br/></section><section id="section-Performance impact" class="section"><h2 class="section-title">Performance impact</h2>None. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>Elimination of confusion; increase of portability between implementations. <br/></section><section id="section-Esthetics" class="section"><h2 class="section-title">Esthetics</h2>Simplifies the scoping issue; eliminates special-case scoping rules for <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> declarations. <br/><br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>Only the <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> declaration has semantic import for <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a>; both proposals specify an incompatible change for this case, to "retract" the expansive scope stated or implied in CLtL.  All other declarations are considered "advice" to an optimizing compiler, and should have no semantic effect on correct programs.  However, programmers making use of such declarations may notice a larger difference in the <a class="proposal-reference" href="#issue-declaration-scope:no-hoisting">NO-HOISTING</a> proposal, since some of their <a class="declaration-reference" href="../chapter-3.xhtml#declaration-inline">inline</a>, <a class="declaration-reference" href="../chapter-3.xhtml#declaration-optimize">optimize</a>, <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a>, etc. declarations will no longer apply to the initial-value forms. <br/>One idiom which will be adversely affected by both of these proposals is:    <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">*a*</span> <span class="syntax-interned-symbol">*a*</span>)</span>)</span>
     <span class="syntax-line-comment syntax-comment">;; rebind *a* to it's "old" value
</span>     <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">*a*</span>)</span>)</span>
     <span class="syntax-interned-symbol">...</span>)</span>
</span></code></pre> where *a* has not been proclaimed special.  This idiom would likely have to be written as:    <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">*a*</span> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-locally">locally</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">*a*</span>)</span>)</span> <span class="syntax-interned-symbol">*a*</span>)</span>)</span>)</span>
     <span class="syntax-line-comment syntax-comment">;; rebind *a* to it's "old" value
</span>     <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">*a*</span>)</span>)</span>
     <span class="syntax-interned-symbol">...</span>)</span>
</span></code></pre> or [preferably!] *a* should be proclaimed special.  Similar idiots  like this may be in use for LAMBDA-Expressions, or <a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a>s etc. <br/>On the other hand, the inadvertent "shadowing" which prevents the  following <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a>'s initial value forms from referencing the input argument is handily solved by either proposal herein.  If neither of these  proposals is not adopted, then the intent of the code for <a class="index/code-reference" href="../chapter-1.xhtml#index/code-bar">bar</a>:   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">bar</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>	      <span class="syntax-line-comment syntax-comment">;[1] 1st instance of x
</span>    <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>	      <span class="syntax-line-comment syntax-comment">;[2] 2nd instance of x &ndash; same as 1st instance?
</span>	  <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>)</span>	      <span class="syntax-line-comment syntax-comment">;[3] 3rd instance
</span>      <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
      <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>)</span>
</span></code></pre> would likely have to be expressed by introducing new <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> contours:   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">bar</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>	      <span class="syntax-line-comment syntax-comment">;[1] 1st instance of x
</span>    <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>	      <span class="syntax-line-comment syntax-comment">;[2] 2nd instance of x &ndash; same as 1st instance?
</span>      <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>)</span>	      <span class="syntax-line-comment syntax-comment">;[3] 3rd instance
</span>        <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
        <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>)</span>)</span>
</span></code></pre> <br/>The source of additional confusion  has long been that <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a> declarations  had to be treated differently from all other declarations; this was because  of the prohibition found on p158 of CLtL.  Given the acceptance of the DECLARE-TYPE-FREE proposal, it no longer is necessary to make an exception  for it, nor to categorize declarations into "pervasive" and "non-pervasive",  or  "free" and "bound". <br/>It is not the purpose of this proposal to alter, clarify or in any  other way bear upon the scoping rules of variables in Common Lisp. However, a few reminders about these rules will help one understand  the above prescription.  Except <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-prog*">prog*</a>, <a class="macro-reference" href="../chapter-6.xhtml#macro-do*">do*</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-labels">labels</a>, and <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-macrolet">macrolet</a>, all the other special forms of CLtL p154 which admit declarations have  the property that the scope of the name binding does not include any initial value form.  As a review of these scopes, note:   &ndash; for <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a>, <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-flet">flet</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-multiple-value-bind">multiple-value-bind</a>, none of the initial value       forms are included in the variables' <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-interned-symbol">functions</span><span class="syntax-quote">'</span>)</span>
</span></code></pre> scope;   &ndash; for DO-&lt;mumble&gt;-SYMBOLS, the initial value forms are not included,      but the optional result forms are included;   &ndash; for <a class="macro-reference" href="../chapter-6.xhtml#macro-do">do</a>, <a class="macro-reference" href="../chapter-6.xhtml#macro-dolist">dolist</a>, and <a class="macro-reference" href="../chapter-6.xhtml#macro-dotimes">dotimes</a>, the initial value forms are not       included, but the stepper forms and the optional result forms       are included;   &ndash; for <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-prog*">prog*</a>, and <a class="macro-reference" href="../chapter-6.xhtml#macro-do*">do*</a>, a variable's scope also includes the       remaining initial value forms, for subsequent variable bindings;   &ndash; for <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-labels">labels</a> and <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-macrolet">macrolet</a>, a function name's scope includes all the       code forms for the functions being defined by the special form       [a compiler writer must know how not to get into an infinite loop       of substitutions when there are 'in-line' declarations on these       mutually recursive names];   &ndash; for a <a class="macro-reference" href="../chapter-3.xhtml#macro-lambda">lambda</a> application, none of the explicit value forms are        included in the bound variable scoping;  however, the 'initform'      code <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-if">if</a> <span class="syntax-interned-symbol">any</span>)</span>
</span></code></pre> for &amp;optional, &amp;key, and &amp;aux bindings are included       in the same way as <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a> does;   &ndash; for <a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a>, <a class="macro-reference" href="../chapter-3.xhtml#macro-defmacro">defmacro</a>, <a class="macro-reference" href="../chapter-4.xhtml#macro-deftype">deftype</a> and <a class="macro-reference" href="../chapter-5.xhtml#macro-defsetf">defsetf</a> follow the rules for      LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66). <br/>Remember also that new name bindings "shadow" <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">after</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">fashion</span>)</span>
</span></code></pre> any  higher level binding or declarations.  E.g., presuming that no  proclamations are in effect, consider the inner let bindings of:    <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-locally">locally</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-float">float</a> <span class="syntax-interned-symbol">y</span>)</span>)</span> 
     <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-number">5</span>)</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">y</span> <span class="syntax-number">10</span>)</span>)</span> 
       <span class="syntax-cons">(<a class="function-reference" href="../chapter-22.xhtml#function-print">print</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-+">+</a> <span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>)</span>)</span>)</span>
</span></code></pre> then x is bound as local <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-not">not</a> <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a>)</span>
</span></code></pre>; and y is bound with no particular type information [because the 'y' being bound is a different variable than the 'y' declared float in the outer scope]. <br/>It has been suggested that compilers could be a bit more helpful in  detecting anomalous bindings, such as in the <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a> following:   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">bar</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>
    <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span>)</span>
           <span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">y</span>)</span>
           <span class="syntax-cons">(<span class="syntax-interned-symbol">new-x</span> <span class="syntax-interned-symbol">x</span>)</span>)</span>
      <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
      <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-interned-symbol">old-x</span> <span class="syntax-interned-symbol">x</span> <span class="syntax-interned-symbol">new-x</span>)</span>)</span>)</span>
</span></code></pre> The collection of variables named X in the <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">let*</a> binding and initial forms includes both local <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">lexical</span>)</span>
</span></code></pre> and special ones. <br/></section></div></main><footer>Copyright Â© 2021 Jan Moringen</footer></body></html>