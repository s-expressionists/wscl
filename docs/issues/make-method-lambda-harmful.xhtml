<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — MAKE-METHOD-LAMBDA-HARMFUL</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">MAKE-METHOD-LAMBDA-HARMFUL</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-Edit History">Edit History</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-make-method-lambda-harmful:new-operators-incompatible">Proposal NEW-OPERATORS-INCOMPATIBLE</a><ol> <li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Performance impact">Performance impact</a><ol> </ol></li><li><a href="#section-Cost to implementors">Cost to implementors</a><ol> </ol></li><li><a href="#section-Cost to users">Cost to users</a><ol> </ol></li></ol></li><li><a href="#issue-make-method-lambda-harmful:clarify">Proposal CLARIFY</a><ol> <li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Cost to implementors">Cost to implementors</a><ol> </ol></li><li><a href="#section-Cost to users">Cost to users</a><ol> </ol></li></ol></li><li><a href="#issue-apply-method:new-operators-compatible">Proposal NEW-OPERATORS-COMPATIBLE</a><ol> <li><a href="#section-Rationale">Rationale</a><ol> </ol></li></ol></li><li><a href="#section-Current practice">Current practice</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>EXTENSION Issue MAKE-METHOD-LAMBDA-HARMFUL [Extension] [CHANGE]</h1><section id="section-Status" class="status-unknown section"><h2 class="section-title">Status</h2>proposed </section><section id="section-Edit History" class="section"><h2 class="section-title">Edit History</h2>15-Jul-21, Version 1 by Bike. </section><section id="section-References" class="section"><h2 class="section-title">References</h2><a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a>, <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a>, MAKE-METHOD-LAMBDA, METHOD-FUNCTION, COMPUTE-DISCRIMINATING-FUNCTION </section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>  MAKE-METHOD-LAMBDA is considered harmful. Some issues with it are explained in   the paper of that name by Pascal Costanza and Charlotte Herzeel. For example,   to be effective, generic functions must be fully defined at the time <a class="macro-reference" href="../chapter-7.xhtml#macro-defmethod">DEFMETHOD</a>   forms are macroexpanded <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-not">not</a> <span class="syntax-interned-symbol">just</span> <span class="syntax-interned-symbol">evaluated</span>)</span>
</span></code>, and there is a tight coupling   between generic functions and methods, such that it is difficult to have a   generic function with both standard and user defined method classes. It is not   widely implemented in actual Lisp implementations [or at least wasn't at the   time that paper was written <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> check this]. <br/>  Costanza and Herzeel's solution is to generalize method functions to take   keyword parameters, while deleting MAKE-METHOD-LAMBDA. This solves the   problems they identify, but there are other issues they do not tackle, and   their solution involves some performance penalties. Method functions must   process keyword arguments. More subtly, some implementations actually bypass   the METHOD-FUNCTION protocol altogether when this is invisible in order to   invoke methods more efficiently, but custom method functions cannot access   these internal and much faster method invocations. <br/>  Another issue with MAKE-METHOD-LAMBDA is that its definition alters that of   the local macro <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> used within method combinations, but this   alteration is not fully explained. MOP redefines <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> such that it can   take any number of arguments and that method functions must expect these   arguments, but does not explain how arguments to <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> are evaluated   <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-interned-symbol">more</span> <span class="syntax-interned-symbol">likely</span> <a class="function-reference" href="../chapter-5.xhtml#function-not">not</a> <span class="syntax-interned-symbol">evaluated</span>)</span>
</span></code>, which is important given that it's a macro. <br/>  In the standard itself, <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> is a somewhat unusual operator, but its   accessory <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> is worse. For example, the class of methods that   <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> produces is not defined, and indeed would be difficult to define   given that method classes may take initialization arguments unknown to this   standard macro. Despite being defined as a local macro, <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> can only   be validly used in very specific positions in a <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> (which, again,   MAKE-METHOD-LAMBDA does not explain the extension of <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> can extra parameters to   <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> include <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a>?). The form within a <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> is specified   to be evaluated in a very specific environment, a null lexical environment   with a local macro for <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> and no bindings named with symbols visible   from the common-lisp-user-package. Given that <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> forms can appear in   method combination expansions controlled by the user, if taken literally   this would mean that the implementation would somehow need to hide the user's   own bindings should those bindings be named by such symbols. <br/>  The METHOD-FUNCTIONs defined by MOP take a list of arguments and a list of   next methods as arguments. This entails substantial overhead. Standard generic   functions must cons a &amp;rest list, and each standard method invoked must   traverse this list to parse out its arguments. MOP does not require method   functions to prevent the arguments list or next methods list from escaping, so   strictly speaking the arguments list cannot be consed with dynamic extent <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">on</span>
  <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">stack</span>)</span>
</span></code></pre>. MOP does not seem to state that method functions cannot alter the   arguments list or list of next methods, which could have unfortunate   consequences, and could imply that the list of next methods must be consed   more than once. To use <a class="function-reference" href="../chapter-7.xhtml#function-call-next-method">CALL-NEXT-METHOD</a>, standard method functions must   <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">briefly</span>)</span>
</span></code> traverse the list of next methods. This issues are serious enough   that at least two implementations, SBCL and Clasp, entirely bypass the use of   standard method functions unless there could be visible effects of doing so <a class="function-reference" href="../chapter-12.xhtml#function--">-</a>   such as when nonstandard method classes are used, which means nonstandard   methods are less performant than standard ones even if they do not have a   different calling protocol or specialize MAKE-METHOD-LAMBDA at all. <br/></section><section class="status-unknown proposal" id="issue-make-method-lambda-harmful:new-operators-incompatible"><h2 class="section-title">Proposal NEW-OPERATORS-INCOMPATIBLE</h2>  Delete MAKE-METHOD-LAMBDA and METHOD-FUNCTION. The fashion in which standard   methods are invoked, and how <a class="macro-reference" href="../chapter-7.xhtml#macro-defmethod">DEFMETHOD</a> is expanded, are left to the   implementation <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">except</span> <span class="syntax-interned-symbol">that</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <a class="type-reference" href="../chapter-4.xhtml#type-class">class</a> <span class="syntax-interned-symbol">of</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <a class="type-reference" href="../chapter-4.xhtml#type-method">method</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">initargs</span> <span class="syntax-interned-symbol">to</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a>
  <span class="syntax-interned-symbol">newly</span> <span class="syntax-interned-symbol">produced</span> <a class="type-reference" href="../chapter-4.xhtml#type-method">method</a> <span class="syntax-interned-symbol">are</span> <span class="syntax-interned-symbol">still</span> <span class="syntax-interned-symbol">defined</span> <span class="syntax-interned-symbol">by</span> <span class="syntax-interned-symbol">CLOS</span> <a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">MOP</span>)</span>
</span></code></pre>. <br/>  Add new operators APPLY-METHOD and EXPAND-APPLY-METHOD, described in detail in   the accompanying pages. <br/>  Delete the <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> local macro and replace it with the definition of   <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> as a symbol described in the accompanying pages. Replace the   definition of the <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> local macro with that in the accompanying pages. <br/>  Edit the description of the generic function invocation protocol in the   definition of COMPUTE-DISCRIMINATING-FUNCTION to describe the new system. <br/>  Add a glossary entry for "<a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">make-method</a> expression". <br/><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  Improves extensibility of method invocation while maintaining performance in   cases people actaully use. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>  This gives users and implementations great freedom in choosing how to   implement method invocation. How a method is invoked depends on the method   but not on the generic function, loosening the coupling identified in   "make-method-lambda considered harmful". Similarly the strange compile time   behavior with MAKE-METHOD-LAMBDA is eliminated. <br/>  Methods can invoke their next methods without concerning themselves with   the implementation details of how those methods are invoked, allowing   methods of multiple classes to be mixed in the same generic function. <br/>  <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> and <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> are made clearer. <br/></section><section id="section-Performance impact" class="section"><h2 class="section-title">Performance impact</h2>  Performance of nonstandard methods is improved. The APPLY-METHOD protocol   basically takes advantage of the fact that, in any given effective method,   the list of next methods is essentially fixed. <br/></section><section id="section-Cost to implementors" class="section"><h2 class="section-title">Cost to implementors</h2>  Substantial. I don't know of any implementation that would require an   outright rewrite of the entire system, but it would take some work to do   this. <br/></section><section id="section-Cost to users" class="section"><h2 class="section-title">Cost to users</h2>  Anyone using MAKE-METHOD-LAMBDA will have to rewrite their systems. Anyone   using METHOD-FUNCTION to call methods will have to do some work. A shim   METHOD-FUNCTION could be defined as   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">method-function</span> <span class="syntax-cons">(<a class="type-reference" href="../chapter-4.xhtml#type-method">method</a>)</span>
      <span class="syntax-cons">(<a class="macro-reference" href="../chapter-3.xhtml#macro-lambda">lambda</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">arguments</span> <span class="syntax-interned-symbol">next-methods</span>)</span>
        <span class="syntax-cons">(<a class="function-reference" href="../chapter-3.xhtml#function-eval">eval</a> <span class="syntax-quasiquote">`<span class="syntax-cons">(<span class="syntax-interned-symbol">apply-method</span> <span class="syntax-unquote">,<a class="type-reference" href="../chapter-4.xhtml#type-method">method</a></span> <span class="syntax-cons">(<span class="syntax-unquote">,<span class="syntax-interned-symbol">next-methods</span></span>)</span> <span class="syntax-quote">'<span class="syntax-unquote">,<span class="syntax-interned-symbol">arguments</span></span></span>)</span></span>)</span>)</span>)</span>
</span></code></pre>   but this would obviously be much slower to use. <br/>  More generally, any system in which the list of next methods is not fixed   by the context of an effective method will be much more awkward. <br/>  No extensive survey has been conducted, but use of either operator is   probably rare. [TODO: Check that.] <br/>  Requiring users to define their own method-defining macros could cause them   to have to do more work. It may be worthwhile to explore operators MOP   could export to ease this process, such as operators to parse specializer   names, or to parse out qualifiers from a <a class="macro-reference" href="../chapter-7.xhtml#macro-defmethod">DEFMETHOD</a> form. <br/></section></section><section class="status-unknown proposal" id="issue-make-method-lambda-harmful:clarify"><h2 class="section-title">Proposal CLARIFY</h2>  Rewrite the description of <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> to state that it can take any number   of arguments after the method, and that these arguments will be passed,   unevaluated, to the method function, except that the first argument after the   method must be a list, and if any elements of this list are <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a>   expressions a method will be passed at that position in the list instead,   where the method is produced as explained below. <br/>  Delete the definition of <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> as a local macro and define it as a   symbol, similar to the accompanying documents. In particular, rewrite the   description of <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> to state that the form is evaluated in the lexical   environment the <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> form is in, possibly augmented as etc., rather   than a null lexical environment. <br/>  Define that when a <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> expression is made into a method, it is   produced by calling <a class="function-reference" href="../chapter-7.xhtml#function-make-instance">MAKE-INSTANCE</a> on the GENERIC-FUNCTION-METHOD-CLASS of the   generic function with at least the initargs: <br/>  * :qualifiers <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> nil   * :lambda-list <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> the GENERIC-FUNCTION-LAMBDA-LIST of the generic function   * :specializers <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> a proper list of the appropriate length in which all     elements are the class <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a>. (Note that this means the next methods list may     not be correctly sorted by specificity.)   * :function <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> a function of one or more arguments. The first argument is the     list of arguments to the method, and further arguments are ignored. The     body of the function is the form in the <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> expression. Uses of     <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> in that form use the first argument as their method arguments. <br/>  Add text stating that method functions in conforming programs cannot let the   method arguments or next method list escape, or mutate them. <br/>  Add a glossary entry for "<a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">make-method</a> expression". <br/><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  Clarifies the behavior of MAKE-METHOD-LAMBDA and method functions without   breaking existing code, unless that code relied on mutating method lists or   something. Clarifies <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> and <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a>. <br/></section><section id="section-Cost to implementors" class="section"><h2 class="section-title">Cost to implementors</h2>  Low to moderate. Some implementations may have to change how <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a>   works. <br/></section><section id="section-Cost to users" class="section"><h2 class="section-title">Cost to users</h2>  None, unless they relied on mutating method lists or something. <br/></section></section><section class="status-unknown proposal" id="issue-apply-method:new-operators-compatible"><h2 class="section-title">Proposal NEW-OPERATORS-COMPATIBLE</h2>  Add the new APPLY-METHOD and EXPAND-APPLY-METHOD operators. Deprecate but do   not delete MAKE-METHOD-LAMBDA and METHOD-FUNCTION. Rewrite <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> and   <a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">MAKE-METHOD</a> as described in <a class="proposal-reference" href="#issue-make-method-lambda-harmful:clarify">CLARIFY</a>, except eliminate the description of   <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> passing its arguments unevaluated, and incorporate the material in   the accompanying documents specifying that it uses EXPAND-APPLY-METHOD. In   the description of EXPAND-APPLY-METHOD, strike the line saying the expansion   for standard methods is unspecified, and instead state that the expansion   calls the METHOD-FUNCTION. State that for the standard method, the extra   <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> arguments past the first are passed to the method function   unevaluated, and the next method list is processed as described in <a class="proposal-reference" href="#issue-make-method-lambda-harmful:clarify">CLARIFY</a>. <br/>  Add text stating that method functions in conforming programs cannot let the   method arguments or next method list escape, or mutate them. <br/>  Edit the description of the generic function invocation protocol in the   definition of COMPUTE-DISCRIMINATING-FUNCTION to describe the new system. <br/>  Add a glossary entry for "<a class="macro-reference" href="../chapter-7.xhtml#macro-make-method">make-method</a> expression". <br/><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  Combines the above two proposals, so that new code can use the new operators   while old code continues to work. More detailed benefits etc of this   proposal are a combination of those in the above two proposals. <br/></section></section><section id="section-Current practice" class="section"><h2 class="section-title">Current practice</h2>  Clasp implements, roughly, <a class="proposal-reference" href="#issue-apply-method:new-operators-compatible">NEW-OPERATORS-COMPATIBLE</a>. SBCL implements   MAKE-METHOD-LAMBDA but beyond that I'm not sure. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>  <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> explicitly allows shadowing. This is different from every other   standard local macro or function, but greatly increases the ability to use   effective methods in unusual contexts, as is useful for some exotic MOP work.   That said, it might cause problems with implementations' "package lock"   facilities. If it's too much to overcome, an alternate operator could be   defined, WITH-CALL-METHOD or something. <br/>  Some problems relating to <a class="function-reference" href="../chapter-24.xhtml#function-compile-file">COMPILE-FILE</a> are not gone into here. Since this   proposal lets users use <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> and APPLY-METHOD directly, it would be   possible to use <a class="function-reference" href="../chapter-24.xhtml#function-compile-file">COMPILE-FILE</a> on code using these operators, and in this case   it is not explicitly defined here whether externalizability problems could   result. <a class="macro-reference" href="../chapter-7.xhtml#macro-call-method">CALL-METHOD</a> and APPLY-METHOD involve literal methods, but may expand   into code that doesn't. It could perhaps be noted for example that whether the   standard EXPAND-APPLY-METHOD method returns code with unexternalizable objects   in it is undefined. </section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>