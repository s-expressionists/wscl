<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — REST-LIST-ALLOCATION</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">REST-LIST-ALLOCATION</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem description">Problem description</a><ol> </ol></li><li><a href="#issue-rest-list-allocation:newly-allocated">Proposal NEWLY-ALLOCATED</a><ol> </ol></li><li><a href="#issue-rest-list-allocation:may-share">Proposal MAY-SHARE</a><ol> </ol></li><li><a href="#issue-rest-list-allocation:must-share">Proposal MUST-SHARE</a><ol> </ol></li><li><a href="#section-Examples">Examples</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current practice">Current practice</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of non-adoption">Cost of non-adoption</a><ol> </ol></li><li><a href="#section-Performance impact">Performance impact</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Esthetics">Esthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue REST-LIST-ALLOCATION [Cleanup] [CLARIFICATION]</h1><h2>Related issues</h2><ul><li><a class="issue-reference" href="../issues/dynamic-extent.xhtml#issue-dynamic-extent">DYNAMIC-EXTENT</a></li></ul><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>Proposal <a class="proposal-reference" href="#issue-rest-list-allocation:may-share">MAY-SHARE</a> passed, Jan 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>CLtL pp 107-108 (<a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>) </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>8-Dec-88, Version 1 by Masinter 9-Dec-88, Version 2 by Clinger (add rationale, more discussion) 12-Dec-88, Version 3 by Clinger (delete bogus examples) </section><section id="section-Problem description" class="section"><h2 class="section-title">Problem description</h2>In the special case of calling a function with an <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> list via <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>, Common Lisp fails to specify whether a new copy of the list is freshly allocated.  For example, given <br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defvar">DEFVAR</a> <span class="syntax-interned-symbol">*MY-LIST*</span> <span class="syntax-quote">'<span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-interned-symbol">B</span> <span class="syntax-interned-symbol">C</span>)</span></span>)</span>
</span></code> <br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">DEFUN</a> <span class="syntax-interned-symbol">FOO</span> <span class="syntax-cons">(<a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> <span class="syntax-interned-symbol">X</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-eq">EQ</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-interned-symbol">*MY-LIST*</span>)</span>)</span>
</span></code> <br/>does  <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">FOO</span></span> <span class="syntax-interned-symbol">*MY-LIST*</span>)</span>
</span></code> return <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a>? <br/>This issue is different from the question of the extent of "rest lists" in the case when they *are* newly allocated which is indefinite; the issue <a class="declaration-reference" href="../chapter-3.xhtml#declaration-dynamic-extent">DYNAMIC-EXTENT</a> also contains some proposals about extent. <br/></section><section class="status-unknown proposal" id="issue-rest-list-allocation:newly-allocated"><h2 class="section-title">Proposal NEWLY-ALLOCATED</h2>Specify that <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> lists are newly allocated in the case when the function is called via <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>. <br/></section><section class="status-passed proposal" id="issue-rest-list-allocation:may-share"><h2 class="section-title">Proposal MAY-SHARE</h2>Specify that the value of an <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> parameter is permitted, but not required, to share <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">top-level</span>)</span>
</span></code> structure with the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>. <br/></section><section class="status-unknown proposal" id="issue-rest-list-allocation:must-share"><h2 class="section-title">Proposal MUST-SHARE</h2>Specify that the value of an <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> parameter is required to share <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">top-level</span>)</span>
</span></code> structure with the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>. <br/>&gt;&gt; this needs better spec about how the args match &lt;&lt;  <br/></section><section id="section-Examples" class="section"><h2 class="section-title">Examples</h2><pre> <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defvar">DEFVAR</a> <span class="syntax-interned-symbol">*MY-LIST*</span> <span class="syntax-quote">'<span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-interned-symbol">B</span> <span class="syntax-interned-symbol">C</span>)</span></span>)</span>
</span></code><br/><br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">DEFUN</a> <span class="syntax-interned-symbol">FOO</span> <span class="syntax-cons">(<a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> <span class="syntax-interned-symbol">X</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-eq">EQ</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-interned-symbol">*MY-LIST*</span>)</span>)</span>
</span></code><br/><br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">FOO</span></span> <span class="syntax-interned-symbol">*MY-LIST*</span>)</span>
</span></code> <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a> ;on Symbolics systems and probably<br/>			      ; many stock hardware implementations<br/><br/>This implies that<br/><br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">DEFUN</a> <span class="syntax-interned-symbol">BAR</span> <span class="syntax-cons">(<a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> <span class="syntax-interned-symbol">X</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-rplaca">RPLACA</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">D</span></span>)</span>)</span>
</span></code><br/><br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">BAR</span></span> <span class="syntax-interned-symbol">*MY-LIST*</span>)</span>
</span></code><br/><br/> *MY-LIST* <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">D</span> <span class="syntax-interned-symbol">B</span> <span class="syntax-interned-symbol">C</span>)</span>
</span></code> ;on Symbolics systems and probably many stock<br/>		      ; hardware implementations<br/><br/>Another example: which of the following have the same semantics?<br/><br/>    <code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">x</span> <span class="syntax-quote">'<span class="syntax-cons">(<span class="syntax-number">1</span> <span class="syntax-number">2</span> <span class="syntax-number">3</span>)</span></span>)</span>
</span></code><br/><br/>    [1] <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">apply</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">foo</span></span> <span class="syntax-number">1</span> <span class="syntax-number">2</span> <span class="syntax-number">3</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span>
</span></code><br/>    [2] <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">apply</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">foo</span></span> <span class="syntax-number">1</span> <span class="syntax-number">2</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-cddr">cddr</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
</span></code><br/>    [3] <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">apply</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">foo</span></span> <span class="syntax-number">1</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-cdr">cdr</a> <span class="syntax-interned-symbol">x</span>)</span>)</span>
</span></code><br/>    [4] <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">apply</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">foo</span></span> <span class="syntax-interned-symbol">x</span>)</span>
</span></code><br/>    [5] <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-funcall">funcall</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">foo</span></span> <span class="syntax-number">1</span> <span class="syntax-number">2</span> <span class="syntax-number">3</span>)</span>
</span></code><br/><br/>Under <a class="issue-reference" href="#issue-rest-list-allocation:newly-allocated">REST-LIST-ALLOCATION:NEWLY-ALLOCATED</a>:<br/>  [1]<a class="function-reference" href="../chapter-12.xhtml#function--">-</a>[5] are equivalent.<br/>Under <a class="issue-reference" href="#issue-rest-list-allocation:may-share">REST-LIST-ALLOCATION:MAY-SHARE</a>:<br/>  Any answer to the question is correct for some conceivable implementation.<br/>  Abstracting over implementations, this means that [1]<a class="function-reference" href="../chapter-12.xhtml#function--">-</a>[5] are pairwise<br/>  non-equivalent.<br/>Under <a class="issue-reference" href="#issue-rest-list-allocation:must-share">REST-LIST-ALLOCATION:MUST-SHARE</a>:<br/>  [1]<a class="function-reference" href="../chapter-12.xhtml#function--">-</a>[4] are pairwise non-equivalent in all implementations.  This proposal<br/>  leaves open the question of whether [1] is equivalent to [5].<br/><br/>And finally:<br/><br/>Should     <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">foo</span> <span class="syntax-cons">(<a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;rest</a> <span class="syntax-interned-symbol">x</span>)</span> <span class="syntax-interned-symbol">...</span>)</span>
</span></code><br/><br/>     behave <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">aside</span> <span class="syntax-interned-symbol">from</span> <span class="syntax-interned-symbol">efficiency</span>)</span>
</span></code> as if it were defined:<br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">foo</span> <span class="syntax-cons">(<a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;rest</a> <span class="syntax-interned-symbol">G0047</span>)</span>     <span class="syntax-line-comment syntax-comment">;Gensym really
</span>      <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">x</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-copy-list">copy-list</a> <span class="syntax-interned-symbol">G0047</span>)</span>)</span>)</span>
         <span class="syntax-interned-symbol">...</span>)</span>)</span>
</span></code></pre><br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>The semantics of <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> is unclear.  In consequence it is impossible to write portable code that relies on <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> arguments sharing structure with the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>.  Portable code can rely on <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> arguments *not* sharing structure with the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>, but only by performing an explicit <a class="function-reference" href="../chapter-14.xhtml#function-copy-list">COPY-LIST</a> on all <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> arguments; this is redundant and inefficient in implementations where <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> arguments are newly allocated anyway. <br/></section><section id="section-Current practice" class="section"><h2 class="section-title">Current practice</h2>Some implementations always share. Some implementations never share. A few may share interpreted and not share compiled, or vice versa. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>None for <a class="proposal-reference" href="#issue-rest-list-allocation:may-share">MAY-SHARE</a>, since that is the status quo.  Both of the other proposals entail a significant cost for some implementations. If <a class="proposal-reference" href="#issue-rest-list-allocation:must-share">MUST-SHARE</a> is adopted, then implementations that don't share structure may be nearly impossible to convert.  If <a class="proposal-reference" href="#issue-rest-list-allocation:newly-allocated">NEWLY-ALLOCATED</a> is adopted, then implementations that do share will have to insert a call to <a class="function-reference" href="../chapter-14.xhtml#function-copy-list">COPY-LIST</a> inside either <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> or <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> list handling, which will slow things down and may be difficult as well. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>No matter what, somebody gets hurt.  <a class="proposal-reference" href="#issue-rest-list-allocation:may-share">MAY-SHARE</a> means you have to write awkward and inefficient code if you care.  (This is already the case for portable code.)  <a class="proposal-reference" href="#issue-rest-list-allocation:must-share">MUST-SHARE</a> means you have to add explicit calls to <a class="function-reference" href="../chapter-14.xhtml#function-copy-list">COPY-LIST</a> to code that assumes the contrary. <a class="proposal-reference" href="#issue-rest-list-allocation:newly-allocated">NEWLY-ALLOCATED</a> means you have to rewrite code that assumes sharing. <br/></section><section id="section-Cost of non-adoption" class="section"><h2 class="section-title">Cost of non-adoption</h2>Great confusion over the issue.  A certain amount of awkwardness and inefficiency would remain inevitable if you want to write portable code. <br/></section><section id="section-Performance impact" class="section"><h2 class="section-title">Performance impact</h2><a class="proposal-reference" href="#issue-rest-list-allocation:must-share">MUST-SHARE</a> costs least in consing, but might slow down function call  for some implementations.  <a class="proposal-reference" href="#issue-rest-list-allocation:may-share">MAY-SHARE</a> lets implementations pick, has least impact.  <a class="proposal-reference" href="#issue-rest-list-allocation:newly-allocated">NEWLY-ALLOCATED</a> requires consing in cases where it didn't before. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>Less confusion.  Improved portability. <br/></section><section id="section-Esthetics" class="section"><h2 class="section-title">Esthetics</h2>Differing, strongly held opinions. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>The Revised3 Report on Scheme specifies that the equivalent of a <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> argument must be a newly allocated list, to avoid precisely this problem. <br/>The argument for <a class="proposal-reference" href="#issue-rest-list-allocation:must-share">MUST-SHARE</a> is that copying is inefficient, so <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> should never cause copying of a list passed to it from <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>. Functions that desire a new copy can just call <a class="function-reference" href="../chapter-14.xhtml#function-copy-list">COPY-LIST</a>. <br/>Two arguments for <a class="proposal-reference" href="#issue-rest-list-allocation:may-share">MAY-SHARE</a> are: <br/><ol><li> In no other place does Common Lisp automatically unshare structure, except when the user is explicitly modifying the structure <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">as</span> <span class="syntax-interned-symbol">in</span> <a class="function-reference" href="../chapter-17.xhtml#function-remove">REMOVE</a>)</span>
</span></code>. Making <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> automatically unshare would be a semantic wart. <br/></li><li> If <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> copies its last argument, recursive programs that receive an <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> argument and pass it to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> become inefficient.  A linear time algorithm can change to a quadratic time algorithm.  While the efficiency could be regained through compiler flow analysis in many cases, it's better not to put the inefficiency into the language in the first place. <br/>The <a class="declaration-reference" href="../chapter-3.xhtml#declaration-dynamic-extent">DYNAMIC-EXTENT</a> proposal would allow <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> lists that were "newly allocated" to have dynamic extent if they were to be passed down via <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a>.  This puts the burden in the right place. <br/>Two <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">closely</span> <span class="syntax-interned-symbol">related</span>)</span>
</span></code> arguments for <a class="proposal-reference" href="#issue-rest-list-allocation:newly-allocated">NEWLY-ALLOCATED</a>: <br/>1. The programmer's model of function calling is simpler: functions take arguments, and any two calls that pass the same arguments to the same function are equivalent.  The <a class="proposal-reference" href="#issue-rest-list-allocation:may-share">MAY-SHARE</a> and <a class="proposal-reference" href="#issue-rest-list-allocation:must-share">MUST-SHARE</a> proposals require a model in which functions generally take their arguments in the form of a list, and the extent to which that list shares structure with other lists in the system becomes an important part of the semantics of a function call. <br/>2.  It's not only smashing a &amp;rest argument that's a problem, it's smashing any list that has been given as the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> as well.  Consider the following in an implementation that doesn't copy the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> when it is passed as a &amp;rest argument: <br/>&gt; <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defvar">defvar</a> <span class="syntax-interned-symbol">*message*</span>)</span>
</span></code> *MESSAGE* &gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <span class="syntax-interned-symbol">set-message</span> <span class="syntax-cons">(<a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;rest</a> <span class="syntax-interned-symbol">mess</span>)</span>
    <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">*message*</span> <span class="syntax-interned-symbol">mess</span>)</span>)</span>
</span></code></pre> SET-MESSAGE &gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">winner</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">a</span></span> <span class="syntax-quote">'<span class="syntax-interned-symbol">winner</span></span>)</span>)</span>)</span>
    <span class="syntax-cons">(<a class="function-reference" href="../chapter-5.xhtml#function-apply">apply</a> <span class="syntax-function">#'<span class="syntax-interned-symbol">set-message</span></span> <span class="syntax-interned-symbol">winner</span>)</span>
    <span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-cdr">cdr</a> <span class="syntax-interned-symbol">winner</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">loser</span></span>)</span>)</span>
    <span class="syntax-interned-symbol">winner</span>)</span>
</span></code></pre> <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-interned-symbol">LOSER</span>)</span>
</span></code> <br/>Is *message* <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-interned-symbol">WINNER</span>)</span>
</span></code> or <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-interned-symbol">LOSER</span>)</span>
</span></code>?  (It might be (#&lt;DTP-LOCATIVE 76123756&gt; #&lt;DTP-ODD-PC 12313453&gt; ...) but that's a different problem.)  This suggests that once a list has been given as the last argument to <a class="function-reference" href="../chapter-5.xhtml#function-apply">APPLY</a> it is no longer OK to modify it. <br/>Gail Zacharias talked about the common idiom of simply doing a <a class="function-reference" href="../chapter-14.xhtml#function-copy-list">COPY-LIST</a> on every &amp;rest argument, to insure some normalcy.  Her reasoning seems to bolster the case for those who claim that the current <a class="package-reference" href="../chapter-11.xhtml#package-cl">CL</a> semantics <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">MAY-SHARE</span>)</span>
</span></code> are deficient: <br/>    Subject: <a class="lambda-list-keyword-reference" href="../chapter-3.xhtml#lambda-list-keyword-rest">&amp;REST</a> Lists     Date: 24 Mar 88 12:23:15 EST (Thu)     From: gz@spt.entity.com (Gail Zacharias)     . . .      If Common Lisp doesn't require unshared &amp;rest lists, then I think     it must provide a declarative version of this idiom so the <a class="function-reference" href="../chapter-14.xhtml#function-copy-list">COPY-LIST</a> can     be portably avoided when it's redundant.  Seems to me that the fact that     this is a common case where users find a need for conditionalization     indicates a real deficiency in Common Lisp's specification.     . . .  <br/>So we have a responsibility to resolve the very thorny issue of <a class="issue-reference" href="#issue-rest-list-allocation">REST-LIST-ALLOCATION</a>. </li></ol></section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>