<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — DYNAMIC-EXTENT-FUNCTION</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">DYNAMIC-EXTENT-FUNCTION</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-dynamic-extent-function:extend">Proposal EXTEND</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of Non-Adoption">Cost of Non-Adoption</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Aesthetics">Aesthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue DYNAMIC-EXTENT-FUNCTION [CLEANUP] [ADDITION]</h1><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>passed, jun 89 X3j13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>Scope and Extent <a class="issue-reference" href="../issues/dynamic-extent.xhtml#issue-dynamic-extent">X3J13 Issue DYNAMIC-EXTENT</a> </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>04-Apr-89, Version 1 by Loosemore 11-Jun-89, Version 2 by Loosemore <br/></section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>  Proposal <a class="issue-reference" href="../issues/dynamic-extent.xhtml#issue-dynamic-extent:new-declaration">DYNAMIC-EXTENT:NEW-DECLARATION</a>, passed at the March 89    meeting, provides a mechanism for declaring that the values of   variables have only dynamic <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">rather</span> <span class="syntax-interned-symbol">than</span> <span class="syntax-interned-symbol">indefinite</span>)</span>
</span></code></pre> extent.  It   would be useful to have similar functionality to indicate that   functional bindings may have only dynamic extent.  (For example,   this would permit compilers to stack-allocate closures.) <br/></section><section class="status-passed proposal" id="issue-dynamic-extent-function:extend"><h2 class="section-title">Proposal EXTEND</h2>  Extend the <a class="declaration-reference" href="../chapter-3.xhtml#declaration-dynamic-extent">dynamic-extent</a> declaration to accept arguments that are   lists of the form <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-function">function</a> <span class="syntax-interned-symbol">&lt;name&gt;</span>)</span>
</span></code></pre> where &lt;name&gt; is a function name,   as well as symbols. <br/>  A <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-function">function</a> <span class="syntax-interned-symbol">&lt;name&gt;</span>)</span>
</span></code></pre> list appearing in a <a class="declaration-reference" href="../chapter-3.xhtml#declaration-dynamic-extent">dynamic-extent</a> declaration is   used to declare that the lexically visible functional binding of &lt;name&gt;   has dynamic extent.  Except for the interpretation of &lt;name&gt; as the   name of a function instead of the name of a variable, such a declaration   otherwise has semantics that are identical to those already described   in proposal <a class="issue-reference" href="../issues/dynamic-extent.xhtml#issue-dynamic-extent:new-declaration">DYNAMIC-EXTENT:NEW-DECLARATION</a>. <br/></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  This permits a programmer to offer advice to an implementation about   what functions may be <a class="glossary-reference" href="../chapter-26.xhtml#glossary-stack-allocated">stack-allocated</a> for efficiency. <br/>  It may be difficult or impossible for a compiler to infer this   same information statically. <br/></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2>  JonL says that Lucid's compiler can stack-allocate closures, but they   have no mechanism for programmers to give the compiler permission to   do so. <br/>  HPCL-I has an UPWARD-CLOSURES declaration that pervasively affects   all closures created within the scope of the declaration. <br/>  The Symbolics Genera compiler can often infer when functions can be    implemented to have dynamic extent.  Also, if a function has a   <span class="issue-reference error">issue:SYS:DOWNWARD-FUNCTION</span> declaration in front of its body, then the   function is implemented with dynamic extent regardless of whether   the compiler thinks all uses are "downward".  (This declaration is   rather peculiar because its scope is actually larger than the lambda   expression containing the declaration; implementationally, it's the   surrounding function definition.) <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>  No cost is forced since implementations are permitted to simply   ignore the <a class="declaration-reference" href="../chapter-3.xhtml#declaration-dynamic-extent">dynamic-extent</a> declaration.   <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>  None. This change is upward compatible. <br/>  There may be some hidden costs to debugging using this declaration <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-interned-symbol">any</span>
  <span class="syntax-interned-symbol">feature</span> <span class="syntax-interned-symbol">which</span> <span class="syntax-interned-symbol">permits</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">user</span> <span class="syntax-interned-symbol">to</span> <span class="syntax-interned-symbol">access</span> <span class="syntax-interned-symbol">dynamic</span> <span class="syntax-interned-symbol">extent</span> <span class="syntax-interned-symbol">objects</span> <span class="syntax-interned-symbol">without</span>
  <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">compiler</span> <span class="syntax-interned-symbol">proving</span> <span class="syntax-interned-symbol">that</span> <span class="syntax-interned-symbol">they</span> <span class="syntax-interned-symbol">are</span> <span class="syntax-interned-symbol">appropriate</span>)</span>
</span></code></pre>. If the user misdeclares   something and returns a pointer into the stack <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-interned-symbol">stores</span> <span class="syntax-interned-symbol">it</span> <span class="syntax-interned-symbol">in</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">heap</span>)</span>
</span></code></pre>,   an undefined situation may result and the integrity of the Lisp storage   mechanism may be compromised. Debugging these situations may be tricky,   but users who have asked for this feature have indicated a willingness   to deal with such costs. Nevertheless, the perils should be clearly   documented and casual users should not be encouraged to use this   declaration. <br/></section><section id="section-Cost of Non-Adoption" class="section"><h2 class="section-title">Cost of Non-Adoption</h2>  Some portable code would be forced to run more slowly <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">due</span> <span class="syntax-interned-symbol">to</span>
  <span class="syntax-interned-symbol">GC</span> <span class="syntax-interned-symbol">overhead</span>)</span>
</span></code></pre>, or to use non-portable language features. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>  The cost of non-adoption is avoided. <br/></section><section id="section-Aesthetics" class="section"><h2 class="section-title">Aesthetics</h2>  This declaration allows a fairly low level optimization to work   by asking the user to provide only very high level information.   The alternatives (sharpsign conditionals, some of which may   lead to more bit-picky abstractions) are far less aesthetic. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>  Loosemore supports <a class="issue-reference" href="#issue-dynamic-extent-function:extend">DYNAMIC-EXTENT-FUNCTION:EXTEND</a>. <br/>  This proposal does not attempt to address the issue of specifying   dynamic extent for anonymous closures <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">which</span> <span class="syntax-interned-symbol">is</span> <span class="syntax-interned-symbol">really</span> <span class="syntax-interned-symbol">a</span> <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-case">case</a>
  <span class="syntax-interned-symbol">of</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">more</span> <span class="syntax-interned-symbol">general</span> <span class="syntax-interned-symbol">problem</span> <span class="syntax-interned-symbol">of</span> <span class="syntax-interned-symbol">specifying</span> <span class="syntax-interned-symbol">dynamic</span> <span class="syntax-interned-symbol">extent</span> <span class="syntax-interned-symbol">for</span> <span class="syntax-interned-symbol">unnamed</span>
  <span class="syntax-interned-symbol">objects</span> <span class="syntax-interned-symbol">of</span> <span class="syntax-interned-symbol">any</span> <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a>)</span>
</span></code></pre>.  It's possible, although often awkward, to   restructure the program to give the object a name and explicitly   identify its extent. <br/>  One possible solution to the problem of dynamic extent for anonymous   lambdas would be to clarify that a reference to a closed-over variable   or function appearing lexically within a <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-function">function</a> form is enough to   cause its value to be "saved" when the <a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-function">function</a> form is executed,   regardless of whether or not that reference is actually executed when   the resulting function is called.  Then, if all of the closed-over   functions and variables referenced within a closure are declared to   have dynamic extent, the closure could be assumed to have dynamic   extent as well.  (More precisely, its maximum extent would be the   intersection of the extents of the closed-over functions and   variables.) </section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>