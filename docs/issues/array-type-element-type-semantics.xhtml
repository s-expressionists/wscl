<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp â€” ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem description">Problem description</a><ol> </ol></li><li><a href="#issue-array-type-element-type-semantics:unify-upgrading">Proposal UNIFY-UPGRADING</a><ol> </ol></li><li><a href="#section-Examples">Examples</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of non-adoption">Cost of non-adoption</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Esthetics">Esthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS [Cleanup] [CHANGE]</h1><h2>Related issues</h2><ul><a class="issue-reference" href="../issues/subtypep-too-vague.xhtml#issue-subtypep-too-vague">SUBTYPEP-TOO-VAGUE</a><span class="issue-reference error">issue:LIST-TYPE-SPECIFIER</span></ul><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>Passed, Jan 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45 Functions: <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> and <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a>; CLtL Sect. 6.2.1, p.72 <a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a>, CLtL p. 291 The type-specifiers: <a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a>,  <a class="type-reference" href="../chapter-15.xhtml#type-simple-array">simple-array</a>,  <a class="function-reference" href="../chapter-15.xhtml#function-vector">vector</a>,  <a class="symbol-reference" href="../chapter-2.xhtml#symbol-simple-vector">simple-vector</a> <a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>Version 1, 13-May-88, JonL Version 2, 23-May-88, JonL   (typo fixes, comments from moon, rearrange some discussion) Version 3, 02-Jun-88, JonL   (flush alternate proposal ["flush-upgrading"]; consequently, move more of discussion back to discussion section. Version 4, 01-Oct-88, Jan Pedersen &amp; JonL (reduce discussion, and "cleanup" wordings) (Version 5 edit history missing) Version 6, 6-Oct-88, Moon (fix typos, cover subtypep explicitly, add complex, change name of UPGRADE-ARRAY-ELEMENT-TYPE) Version 7, 7-Oct-88, JonL (more name and wording changes) Version 8,  8-Oct-88, Masinter (wording, discussion) Version 9, 31-Oct-88, JonL (major re-wording to accommodate recent discussion; esp. re-introduce and clarify "upgrading") <br/></section><section id="section-Problem description" class="section"><h2 class="section-title">Problem description</h2> CLtL occasionally draws a distinction between type-specifiers "for  declaration" and "for discrimination";  see CLtL, section 4.5 "Type   Specifiers That Specialize" <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">p.45</span> <a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">following</span>)</span>
</span></code>  The phrase   "for declaration"  encompasses type-specifiers passed in as the   :element-type argument to  <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>, passed in as the &lt;result-type&gt;   argument to <a class="function-reference" href="../chapter-4.xhtml#function-coerce">coerce</a>, and used in <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> and <a class="symbol-reference" href="../chapter-3.xhtml#symbol-declare">declare</a> type declarations.  The   phrase "for discrimination" refers to the type-specifiers passed in as   the &lt;type&gt; argument<code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">s</span>)</span>
</span></code> to <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> and <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a>. <br/> One consequence of this distinction is that a variable declared to be of   type &lt;certain-type&gt;, and all of whose assigned objects are created in   accordance with that type, may still have none of its values ever satisfy   the <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> predicate with that type-specifier.   One type-specifier with   this property is            <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;element-type&gt;</span>)</span>
</span></code>   for various implementation dependent values of &lt;element-type&gt;.  For  example, in most implementations of <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a>, an array X created with an  element-type of <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-signed-byte">signed-byte</a> <span class="syntax-number">5</span>)</span>
</span></code> will, depending on the vendor, either  satisfy         <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-signed-byte">signed-byte</a> <span class="syntax-number">8</span>)</span>)</span></span>)</span>
</span></code>, or         <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a>)</span></span>)</span>
</span></code>   but <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">almost</span>)</span>
</span></code> never will it satisfy          <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-signed-byte">signed-byte</a> <span class="syntax-number">5</span>)</span>)</span></span>)</span>
</span></code>. <br/> This is entirely permissible within the scope of standardization on  <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>, where an implementation is required only to construct up the  result out of "the most specialized [element] type that can nevertheless  accommodate elements of the given type [the :element-type argument]"  (see CLtL, p287).  That is, an implementation may in fact only provide a   very small number of equivalence classes of element-types for storing   arrays, corresponding to its repertoire of specialized storage techniques;  and it is explicitly permitted to "upgrade" any element-type request into   one of its built-in repertoire (see also  CLtL, p45, second and third  paragraphs under Section 4.5.) <br/> As a practical matter, almost every existing implementation does some   serious upgrading of the :element-type argument given to <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>.    Yet the difference between "for declaration" and "for discrimination"   has been very confusing to many people.  Similarly, portability is  hindered when users do not know just how a given implementation does   upgrading. <br/> The type specifier <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;part-type&gt;</span>)</span>
</span></code> also falls in the  domain of CLtL  Section 4.5.  Currently, only one implementation actually provides any kind   of specialized storage for complex parts; and in this case, the practical  matter is less urgent, since the kind of upgrading happening is so obvious   as to cause little or no confusion. <br/></section><section class="status-passed proposal" id="issue-array-type-element-type-semantics:unify-upgrading"><h2 class="section-title">Proposal UNIFY-UPGRADING</h2> Short Summary: <br/>  ** Eliminate the distinction between type-specifiers "for declaration" and      "for discrimination".  In short, change the meaning of array and      complex type specifiers in favor of the "for declaration" meaning. <br/>  ** Change the meaning of <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> to be in accord with "for declaration"      meaning of type-specifiers. <br/>  ** Add an <a class="glossary-reference" href="../chapter-26.xhtml#glossary-implementation-dependent">implementation-dependent</a> function that reveals how a given       type-specifier for array element-types is upgraded.  Add another such       function that reveals how a given type-specifier for complex parts is      upgraded. <br/>  ** Clarify that "upgrading" implies a movement upwards in the type<a class="function-reference" href="../chapter-12.xhtml#function--">-</a>      hierarchy lattice; i.e., if &lt;type&gt; upgrades to &lt;Type&gt;, then      &lt;Type&gt; must be a super-type of &lt;type&gt;. <br/>  ** Clarify that upgrading an array element-type is independent of any       other property of arrays, such as rank, adjustability, fill-pointers,       etc.   <br/>  ** Clarify how <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> thus behaves on array type-specifiers.   <br/>  ** Define how <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> behaves on complex type-specifiers.   <br/> Note that despite this issue's name, the detailed specifications herein   apply to the type system &ndash; not to the behavior of <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>, nor to how  arrays are actually implemented. <br/> Details: <br/>  First, some definitions: Two type-specifiers &lt;type1&gt; and &lt;type2&gt; are said    to be "type-equivalent" if and only if each one specifies a subtype of the   other one.  For example, <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-unsigned-byte">unsigned-byte</a> <span class="syntax-number">5</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-mod">mod</a> <span class="syntax-number">32</span>)</span>
</span></code> are two different    type<a class="function-reference" href="../chapter-12.xhtml#function--">-</a> specifiers that always refer to the same sets of things; hence they    are type-equivalent.  But <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-unsigned-byte">unsigned-byte</a> <span class="syntax-number">5</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-signed-byte">signed-byte</a> <span class="syntax-number">8</span>)</span>
</span></code> are not    type<a class="function-reference" href="../chapter-12.xhtml#function--">-</a> equivalent since the former refers to a proper subset of the latter.   Two type-specifiers &lt;type1&gt; and &lt;type2&gt; are said to be "type-disjoint"   if their specified intersection is null.  For example, <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a> and <a class="function-reference" href="../chapter-12.xhtml#function-float">float</a>    are type disjoint by definition (see CLtL p.33), and <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a> <span class="syntax-number">3</span> <span class="syntax-number">5</span>)</span>
</span></code> and    <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a> <span class="syntax-number">7</span> <span class="syntax-number">10</span>)</span>
</span></code> are type-disjoint because the specified ranges have no   elements in common. <br/> *. Eliminate the distinction between types "for declaration" and "for      discrimination".  In particular, elminate any such reference in the      discussion of array and complex type-specifiers; this would include      documentation patterned after the discussion in section 4.5, pp. 45-7,      especially the example on p.46 that says "See <a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a>".     Change the meaning of <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;element-type&gt;</span>)</span>
</span></code>, as well as any of the     subtypes of <a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> (such as <a class="type-reference" href="../chapter-15.xhtml#type-simple-array">simple-array</a>, <a class="function-reference" href="../chapter-15.xhtml#function-vector">vector</a>, etc.) in favor of the      "for declaration" meaning.  Make the similar simplification for the      &lt;part-type&gt; specifiers in the <a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> type-specifier. <br/> *. Change the meaning of <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-interned-symbol">&lt;x&gt;</span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span></span>)</span>
</span></code>, where &lt;type&gt; is not      *, to be true if and only if &lt;x&gt; is an array that could be the result      of giving &lt;type&gt; as the :element-type argument to <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>.  While     <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <a class="function-reference" href="../chapter-12.xhtml#function-*">*</a>)</span>
</span></code> refers to all arrays regardless of element type, <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code>     refers only to those arrays that can result from giving &lt;type&gt; as the     :element-type argument to the function <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>.  Change the meanings     for <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-15.xhtml#type-simple-array">simple-array</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-vector">vector</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code> in the same way. <br/>    Change the meaning of <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-interned-symbol">&lt;x&gt;</span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span></span>)</span>
</span></code> similarly.  Thus,     <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code> refers to all complex numbers that can result from      giving numbers of type &lt;type&gt; to the function <a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a>, plus all other      complex numbers of the same specialized representation.  Remember that     both the real and the imaginary parts of any such complex number must      satisfy:                 <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-interned-symbol">&lt;real-or-imag-part&gt;</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type&gt;</span></span>)</span>
</span></code>.  <br/> *. Add the function <a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> of one argument, which     returns the element type of the most specialized array representation     capable of holding items of the given argument type.   Note that except     for storage allocation consequences, it could be defined as: <br/>      <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-defun">defun</a> <a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-cons">(<a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a>)</span>
        <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:ELEMENT-TYPE</span> <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a>)</span>)</span>)</span>
</span></code></pre> <br/>    Since element-type upgrading is a fundamental operation implicit in      almost every existing implementation of <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>, the purpose of this      added function is primarily to reveal how an implementation does its     upgrading. <br/>    Add the function <a class="function-reference" href="../chapter-12.xhtml#function-upgraded-complex-part-type">upgraded-complex-part-type</a> of one argument that     returns the part type of the most specialized complex number     representation that can hold parts of the given argument type. <br/> *. Clarify that "upgrading" implies a movement upwards in the type<a class="function-reference" href="../chapter-12.xhtml#function--">-</a>     hierarchy lattice.  Specifically, the type-specifier &lt;type&gt; must be     a subtype of <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type&gt;</span></span>)</span>
</span></code>.  Furthermore, if      &lt;type1&gt; is a subtype of &lt;type2&gt;, then:             <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type1&gt;</span></span>)</span>
</span></code>     must also be a subtype of:             <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type2&gt;</span></span>)</span>
</span></code>.       Note however, that two type-disjoint types can in fact be upgraded into      the same thing. <br/>    Clarify that <a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> returns the upgraded element type     for the array; in particular, any documentation patterned after      the sentence on p. 291 begining "This set may be larger than the      set requested when the array was created; for example . . ." should     be embellished with this clarification. <br/>    Similarly, the type-specifier &lt;type&gt; must be a subtype of      <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-upgraded-complex-part-type">upgraded-complex-part-type</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code>. <br/> *. Clarify that upgrading an array element-type is independent of any      other property of arrays, such as rank, adjustability, fill-pointers,      displacement etc.  For all such properties other than rank this should      be obvious <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">since</span> <span class="syntax-interned-symbol">they</span> <span class="syntax-interned-symbol">are</span> <a class="function-reference" href="../chapter-5.xhtml#function-not">not</a> <span class="syntax-interned-symbol">expressible</span> <span class="syntax-interned-symbol">in</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">language</span> <span class="syntax-interned-symbol">of</span> 
    <span class="syntax-interned-symbol">type-specifiers</span>)</span>
</span></code></pre>; but note that unless it is also independent of rank,      it would not be consistently possible to displace arrays to those of      differing rank. <br/> *. Clarify that <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> on <a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> type-specifiers is as follows:   <br/>    For all type-specifiers &lt;type1&gt; and &lt;type2&gt; other than *, require      <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type1&gt;</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type2&gt;</span>)</span>
</span></code> to be type-equivalent if and only      if they refer to arrays of exactly the same specialized representation;      and require them to be type-disjoint if and only if they refer to arrays      of different, distinct specialized representations.  This definition     follows that implicitly prescribed in CLtL. <br/>    As a consequence of the preceding change to <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> and of the definition      of <a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a>, the two type specifiers                  <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type1&gt;</span>)</span>
</span></code>  and                  <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type2&gt;</span>)</span>
</span></code>     are type-equivalent if and only if                 <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type1&gt;</span></span>)</span>
</span></code>  and                 <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type2&gt;</span></span>)</span>
</span></code>      are type-equivalent.  This is another way of saying that `<code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code>     and `<code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-feature-expression">,(UPGRADED-ARRAY-ELEMENT-TYPE '&lt;type&gt;)</span>)</span>
</span></code> refer to the same     set of specialized array representations. <br/>    This defines the behavior of <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> on array type-specifiers; namely:                 <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type1&gt;</span>)</span></span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type2&gt;</span>)</span></span>)</span>
</span></code>     is true if and only if                 <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type1&gt;</span></span>)</span>
</span></code>  and                 <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type2&gt;</span></span>)</span>
</span></code>     are type-equivalent. <br/> *. Define <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> on <a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> type-specifiers as follows:  <br/>    For all type-specifiers &lt;type1&gt; and &lt;type2&gt; other than *,              <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;type1&gt;</span>)</span></span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;type2&gt;</span>)</span></span>)</span>
</span></code>     is  <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a> <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a>  if: <ol><li> &lt;type1&gt; is a subtype of &lt;type2&gt;, or </li><li> <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-upgraded-complex-part-type">upgraded-complex-part-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type1&gt;</span></span>)</span>
</span></code> is type-equivalent  to <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-upgraded-complex-part-type">upgraded-complex-part-type</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type2&gt;</span></span>)</span>
</span></code>;  in this case,  <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;type1&gt;</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <span class="syntax-interned-symbol">&lt;type2&gt;</span>)</span>
</span></code> both refer to the   same specialized representation. </li></ol>   The result is  <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a> <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a>  otherwise. <br/> The small differences between the <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> specification for <a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> and   for <a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> are necessary because there is no creation function for   complexes which allows one to specify the resultant part type independently  of the actual types of the parts.  Thus in the case of <a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a>, we must   refer to the actual type of the parts, although a number can be a member   of more than one type; e.g., 17 is of type <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-mod">mod</a> <span class="syntax-number">18</span>)</span>
</span></code> as well as of type  <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-mod">mod</a> <span class="syntax-number">256</span>)</span>
</span></code>; and 2.3f5 is of type <a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a> was well as <a class="function-reference" href="../chapter-12.xhtml#function-float">float</a>.  The form:      <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a>)</span></span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-complex">complex</a> <a class="function-reference" href="../chapter-12.xhtml#function-float">float</a>)</span></span>)</span>
</span></code>  must be true in all implementations; but:      <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a>)</span></span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <a class="function-reference" href="../chapter-12.xhtml#function-float">float</a>)</span></span>)</span>
</span></code>  is true only in implementations that do not have a specialized array  representation for single-floats distinct from that for other floats. <br/></section><section id="section-Examples" class="section"><h2 class="section-title">Examples</h2><pre> Let &lt;aet-x&gt; and &lt;aet-y&gt; be two distinct type specifiers that are<br/> definitely not type-equivalent in a given implementation, but for which<br/> <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> will return an object of the same array type.  This will be<br/> an implementation dependent search, but in every implementation that<br/> the proposer has tested, there will be some such types; often,<br/> <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-signed-byte">signed-byte</a> <span class="syntax-number">5</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-signed-byte">signed-byte</a> <span class="syntax-number">8</span>)</span>
</span></code> will work.<br/><br/> Thus, in each case, both of the following forms return <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a> <a class="section-reference" href="../chapter-26.xhtml#section-T">T</a>:<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-x&gt;</span></span>)</span>)</span>
            <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-y&gt;</span></span>)</span>)</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-y&gt;</span></span>)</span>)</span>
            <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-x&gt;</span></span>)</span>)</span>)</span>
</span></code></pre><br/><br/> To eliminate the distinction between "for declaration" and "for<br/> discrimination" both of the following should be true:<br/><br/>  [A]<br/>   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-x&gt;</span></span>)</span>
          <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-x&gt;</span>)</span></span>)</span>
</span></code></pre><br/>   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-y&gt;</span></span>)</span>
          <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-y&gt;</span>)</span></span>)</span>
</span></code></pre><br/><br/> Since <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-x&gt;</span>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-y&gt;</span>)</span>
</span></code> are different names for<br/> exactly the same set of objects, these names should be type-equivalent.<br/> That implies that the following set of tests should also be true:<br/><br/>  [B]<br/>   <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-x&gt;</span>)</span></span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-y&gt;</span>)</span></span>)</span>
</span></code><br/>   <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-y&gt;</span>)</span></span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-x&gt;</span>)</span></span>)</span>
</span></code><br/><br/> Additionally, to show that un-equivalent type-specifiers that use the<br/> same specialized array type should be equivalent as element-type<br/> specifiers, the following type tests should be true:<br/><br/>  [C]<br/>   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-y&gt;</span></span>)</span>
          <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-x&gt;</span>)</span></span>)</span>
</span></code></pre><br/>   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-number">0</span> <span class="syntax-keyword-symbol">:element-type</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;aet-x&gt;</span></span>)</span>
          <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;aet-y&gt;</span>)</span></span>)</span>
</span></code></pre><br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2> This proposal legitimizes current practice, and removes the obscure and  un-useful distinction between type-specifiers "for declaration" and  "for discrimination".  The suggested changes to the interpretation of  array and complex type-specifiers follow from defining type-specifiers  as names for collections of objects, on <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> being a set membership  test, and <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> a subset test on collections of objects. <br/></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2> Every vendor's implementation that the proposer has queried has a finite   set of specialized array representations, such that two non-equivalent   element types can be found that use the same specialized array   representation; this includes Lucid, Vaxlisp, Symbolics, TI, Franz,  and Xerox. Most implementations fail tests [A] and [C] part 1, but pass  tests [A] and [C] part 2; this is a consequence of implementing the  distinction between "for declaration" and "for discrimination".  Lucid  and Xerox both pass test [B], and the other implementations fail it.  The Explorer returns <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a> for all six tests in [A], [B], and [C]. <br/> Allegedly, the PCLS implementation does no "upgrading"; each array  "remembers" exactly the type-specifier handed to the <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> call  that created it.  Thus the test cases are not applicable to PCLS,  since the precondition cannot be met (i.e., find two non-type-equivalent  type-specifiers that are non-trivially upgraded by <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>). <br/> The TI Explorer offers specialized representation for complexes;  part types of <a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a> and <a class="type-reference" href="../chapter-12.xhtml#type-double-float">double-float</a> are specialized. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2> This proposal is an incompatible change to the current language  specification, but only a small amount of work should be required in  each vendor's implementation of <a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> and <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a>. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2> Because of the prevalence of confusion in this area, it seems unlikely  that any user code will have to be changed.  In fact, it is more likely  that some of the vendors will cease to get bug reports about <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>  returning a result that isn't of "the obvious type".  Since the change  is incompatible, some user code might have to be changed. <br/></section><section id="section-Cost of non-adoption" class="section"><h2 class="section-title">Cost of non-adoption</h2> Continuing confusion in the user community. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2> It will greatly reduce confusion in the user community.  The fact that  <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-interned-symbol">&lt;n&gt;</span> <span class="syntax-keyword-symbol">:ELEMENT-TYPE</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">&lt;type&gt;</span></span>)</span>
</span></code> frequently is not of type   <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>
</span></code> has been very confusing to almost everyone.   <br/> Portability of applications will be increased slightly, since  the behavior of       <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-interned-symbol">&lt;n&gt;</span> <span class="syntax-keyword-symbol">:ELEMENT-TYPE</span> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span> <span class="syntax-quote">'<span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span></span>)</span>
</span></code>   will no longer be <a class="glossary-reference" href="../chapter-26.xhtml#glossary-implementation-dependent">implementation-dependent</a>.  <br/></section><section id="section-Esthetics" class="section"><h2 class="section-title">Esthetics</h2> Reducing the confusing distinction between type-specifiers "for  declaration" and "for discrimination" is a simplifying step &ndash; it is a  much simpler rule to state that the type-specifiers actually describe  the collections of data they purport to name.  Thus this is a step  towards increased elegance. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2> This issue was prompted by a lengthy discussion on the Common Lisp  mailing list.  See for example a series of exchanges started on Thu,   17 Dec 87 <span class="issue-reference error">issue:10:48</span>:05 PST by Jeff Barnett &lt;jbarnett@nrtc.northrop.com&gt;  under the subject line of "Types in <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a>".  See also the exchange started   Wed, 6 Jan 88 <span class="issue-reference error">issue:23:21</span>:16 PST by Jon L White &lt;edsel!jonl@labrea.stanford.edu&gt;  under the subject line of "<a class="function-reference" href="../chapter-4.xhtml#function-typep">typep</a> warp implications" <br/> Although the types <a class="function-reference" href="../chapter-16.xhtml#function-string">string</a>,  <a class="symbol-reference" href="../chapter-2.xhtml#symbol-bit-vector">bit-vector</a>,  <a class="type-reference" href="../chapter-16.xhtml#type-simple-string">simple-string</a>, and   <a class="symbol-reference" href="../chapter-2.xhtml#symbol-simple-bit-vector">simple-bit-vector</a> are subtypes of the <a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> type, they are not  specifically discussed in this proposal.  The reason is that   they are not type-specifiers "that specialize", but are merely   abbreviations as follows:    <a class="function-reference" href="../chapter-16.xhtml#function-string">string</a>             ==  <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-vector">vector</a> <span class="syntax-interned-symbol">STRING-CHAR</span>)</span>
</span></code>    <a class="type-reference" href="../chapter-16.xhtml#type-simple-string">simple-string</a>      ==  <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-15.xhtml#type-simple-array">simple-array</a> <span class="syntax-interned-symbol">STRING-CHAR</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-*">*</a>)</span>)</span>
</span></code>    <a class="symbol-reference" href="../chapter-2.xhtml#symbol-bit-vector">bit-vector</a>         ==  <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-vector">vector</a> <a class="function-reference" href="../chapter-15.xhtml#function-bit">bit</a>)</span>
</span></code>    <a class="symbol-reference" href="../chapter-2.xhtml#symbol-simple-bit-vector">simple-bit-vector</a>  ==  <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-15.xhtml#type-simple-array">simple-array</a> <a class="function-reference" href="../chapter-15.xhtml#function-bit">bit</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-*">*</a>)</span>)</span>
</span></code>  Thus their semantics could be affected only in an implementation that  doesn't support a specific "specialized storage" type for arrays of  bits and vectors of string-chars.  But in fact, every <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> implementation   must appear to support "specialized storage" for bit-arrays and strings,  even if it means nothing more than remembering the fact that such an  array was created with that element-type.  This is required in order  for strings, bit-vectors,  and bit-arrays to be disjoint datatypes   (see CLtL p.34; see also the definitions of BIT-ARRAY and <a class="function-reference" href="../chapter-16.xhtml#function-string">string</a> found   in CLtL p.293, Section 17.4, and in CLtL p.299.) <br/> We considered the possibility of flushing the permission to "upgrade";  for example, it could be made a requirement that:      <code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-array-element-type">array-element-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> <span class="syntax-interned-symbol">&lt;n&gt;</span> <span class="syntax-keyword-symbol">:ELEMENT-TYPE</span> <span class="syntax-interned-symbol">&lt;type&gt;</span>)</span>)</span>
</span></code>  always be equal to &lt;type&gt; (or, at least type-equivalent to &lt;type&gt;)  for all valid type specifiers &lt;type&gt;.  This has several problems: it  increases the storage requirement for many kinds of arrays, and hides  a relevant part of the underlying implementation for no apparently   good reason.  However, it would increase portability, since it would be   much more difficult, for example, to write a program that created an  array with one element-type, say, <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-unsigned-byte">unsigned-byte</a> <span class="syntax-number">5</span>)</span>
</span></code>, but operated on it   assuming a non-trivial upgraded element-type, say, <code><span class="syntax-root"><span class="syntax-cons">(<a class="type-reference" href="../chapter-12.xhtml#type-unsigned-byte">unsigned-byte</a> <span class="syntax-number">8</span>)</span>
</span></code>.  Under this proposal, it is valid for an implementation of <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>   to have arrays "remember" the type-equivalence class of the original   :element-type argument; such an implementation would satisfy all of   the  constraints listed above. <br/> We considered a suggestion to restrict the set of "known" array element   types; this would gain portability at the expense of limiting the   language. <br/> We considered leaving out of the proposal the addition of the two  functions <a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> and <a class="function-reference" href="../chapter-12.xhtml#function-upgraded-complex-part-type">upgraded-complex-part-type</a>.  But it was noted that every implementation of <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> supports exactly  that functionality somewhere in its implementation of <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a>; and  exposing this to the user would be a good thing.  Furthermore, the  existence of at least <a class="function-reference" href="../chapter-15.xhtml#function-upgraded-array-element-type">upgraded-array-element-type</a> makes the clarifications  on "upgrading" and <a class="function-reference" href="../chapter-4.xhtml#function-subtypep">subtypep</a> implications easier.  Finally, there would  be no other way at all to pinpoint just how complex parts are upgraded,  since there is no type information available except for the actual  types of the parts. <br/> Since this proposal contains the implication:      <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type1&gt;</span>)</span>
</span></code>  is-type-equivalent-to  <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <span class="syntax-interned-symbol">&lt;type2&gt;</span>)</span>
</span></code>      ==&gt;        &lt;type1&gt;  is-type-equivalent-to  &lt;type2&gt;  then the question naturally arises "Does the reverse implication hold?"    That is, should two non-EQ but type-equivalent type-specifiers &lt;type1&gt;  and &lt;type2&gt; always give rise to the same array types?   For example,   consider <a class="type-reference" href="../chapter-12.xhtml#type-short-float">short-float</a> and <a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a> in an implementation where these   are type-equivalent (see CLtL section 2.1.3).  One may desire to implement   <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <a class="type-reference" href="../chapter-12.xhtml#type-short-float">short-float</a>)</span>
</span></code> and <code><span class="syntax-root"><span class="syntax-cons">(<a class="symbol-reference" href="../chapter-2.xhtml#symbol-array">array</a> <a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a>)</span>
</span></code> differently.  Say, for example   that the former is packed into 16-bit half-words, whereas the latter is   packed into 32-bit words; but for either kind of packing, the result of   <a class="function-reference" href="../chapter-15.xhtml#function-aref">aref</a> is an ordinary "<a class="type-reference" href="../chapter-12.xhtml#type-single-float">single-float</a>".  The whole point of the type-specifier  to <a class="function-reference" href="../chapter-15.xhtml#function-make-array">make-array</a> is merely to specify a packing technique for "packed float"   arrays.  This "krinkle", however, will not be addressed by the proposal   herein; it should simply be remembered that the implication above goes   only one way, and is not an "if-and-only-if" link. </section></div></main><footer>Copyright Â© 2021 Jan Moringen</footer></body></html>