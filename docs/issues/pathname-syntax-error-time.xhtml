<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — PATHNAME-SYNTAX-ERROR-TIME</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">PATHNAME-SYNTAX-ERROR-TIME</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-pathname-syntax-error-time:pathname-creation">Proposal PATHNAME-CREATION</a><ol> <li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li></ol></li><li><a href="#issue-pathname-syntax-error-time:namestring-coercion">Proposal NAMESTRING-COERCION</a><ol> <li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li></ol></li><li><a href="#issue-pathname-syntax-error-time:explicitly-vague">Proposal EXPLICITLY-VAGUE</a><ol> <li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li></ol></li><li><a href="#section-Test Case">Test Case</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Aesthetics">Aesthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue PATHNAME-SYNTAX-ERROR-TIME [NIL] [CLARIFICATION]</h1><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>Proposal <a class="proposal-reference" href="#issue-pathname-syntax-error-time:explicitly-vague">EXPLICITLY-VAGUE</a> passed, Jun 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>File System Interface (pp409-427) </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>07-Jul-88, Version 1 by Pitman </section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>  There exist conceivable pathnames for which there is no valid mapping in a   particular implementation. CLtL is not clear about the time at which this   error might be detected. <br/>  For example, on file systems which constrain pathname-types to be three   letters or fewer, the type "<a class="package-reference" href="../chapter-A.xhtml#package-lisp">lisp</a>" is not valid. The question arises: when   is this error detected? <br/>  In some implementations, the error might be detected while forming the   pathname. That is, <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>
</span></code></pre> signals an error. <br/>  In some implementations, the error might be detected while forming the   namestring. That is, <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>
</span></code></pre> succeeds, but   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>)</span>
</span></code></pre> signals an error. <br/>  In some implementations, validity checking might be done only by the host   operating system, so Lisp does not detect the error unless the operating   system complains. For example, <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>
</span></code></pre> succeeds,   and even <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>)</span>
</span></code></pre> constructs a plausible   looking pathname, but <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-21.xhtml#function-open">open</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>)</span>)</span>
</span></code></pre> fails. <br/>  In some implementations, Lisp might make `friendly' corrections to the   pathname in order to form a namestring. For example,   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>
</span></code></pre> might succeed, but    <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"LISP"</span>)</span>)</span>
</span></code></pre> might produce a namestring with   an extension such as ".LIS" or ".LSP". <br/>  Similar issues might come up in file systems which don't allow wildcard   pathnames. Is :WILD allowed in a name or type slot and then disallowed   upon coercion to a pathname, or is :WILD complained about "up front"? <br/>  This phenomenon is a barrier to portability because if a program is   debugged in an implementation that does, for example, NAMESTRING-time   error checking, the programmer may be lulled into an expectation that   it is acceptable to construct and manipulate invalid pathnames as long   as the problem is caught before an attempt to call <a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> is   attempted. On the other hand, another programmer may debug his code in   a Lisp which does early error checking of syntax and may assume that    he is home free if the pathname gets constructed correctly. <br/></section><section class="status-unknown proposal" id="issue-pathname-syntax-error-time:pathname-creation"><h2 class="section-title">Proposal PATHNAME-CREATION</h2>  Clarify that operations such as <a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> and MERGE-PATHNMES which   construct new pathnames do plausibility checking of their arguments   and signal an error rather than construct a pathname for which <a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a>   would not produce a valid pathname. <br/><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  This would identify clearly to the programmer where he should expect an   error to be signalled for a pathname. <br/>  This would mean that fully constructed pathnames could reliably   be converted to namestrings. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>  Some implementors, especially those which rely on the operating system   to be the sole authority on pathname syntax, might have to introduce   some new syntax-checking facilities. <br/>  Implementations where this error checking is done later would have to be   changed both to do it earlier, and to not make the unwarranted assumption   that pathnames with no valid namestring representation are constructable. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>  The ability to represent non-viable pathnames for the purpose of merging   would be lost. This feature was not portably available, but was available   in some operating systems. <br/>  Some code which expected an error, but expected it at a different time   would have to be changed. <br/></section></section><section class="status-unknown proposal" id="issue-pathname-syntax-error-time:namestring-coercion"><h2 class="section-title">Proposal NAMESTRING-COERCION</h2>  Clarify that it was valid to create a pathname which could not be   converted to a namestring. Require <a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">related</span> <span class="syntax-interned-symbol">functions</span><span class="syntax-interned-symbol">,
  such</span> <span class="syntax-interned-symbol">as</span> <a class="function-reference" href="../chapter-19.xhtml#function-enough-namestring">enough-namestring</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-interned-symbol">any</span> <span class="syntax-interned-symbol">internal</span> <span class="syntax-interned-symbol">functions</span> <span class="syntax-interned-symbol">that</span> <span class="syntax-interned-symbol">might</span> <span class="syntax-interned-symbol">be</span> <span class="syntax-interned-symbol">used</span>
  <span class="syntax-interned-symbol">in</span> <span class="syntax-interned-symbol">place</span> <span class="syntax-interned-symbol">of</span> <a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> <span class="syntax-interned-symbol">by</span> <span class="syntax-interned-symbol">functions</span> <span class="syntax-interned-symbol">like</span> <a class="function-reference" href="../chapter-21.xhtml#function-open">open</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <a class="function-reference" href="../chapter-20.xhtml#function-probe-file">probe-file</a>)</span>
</span></code></pre> to signal   an error for pathnames which do not represent valid filenames in the   designated file system. <br/><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  This would identify clearly to the programmer where he should expect an   error to be signalled for a pathname. <br/>  This would allow the construction of pathnames for the sole purpose of   merging without causing what might seem to some as gratuitous errors. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>  Implementors who rely on the operating system to be the sole authority   on pathname syntax, might have to introduce some new syntax-checking   facilities. <br/>  Implementations where this error checking is done earlier would have to   be changed both to do it later, and to not make the unwarranted   assumption that any pathname has a valid namestring representation. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>  Early error checking of faulty pathnames would be lost. <br/>  Some code which expected an error, but expected it at a different time   would have to be changed. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>  Macsyma, for example, has encountered a need for "hostless" pathnames   <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">in</span> <span class="syntax-interned-symbol">merging</span>)</span>
</span></code></pre>. The concept makes no sense if every pathname must have   a namestring, because a pathname with no host cannot have a namestring.   However, if it's <a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a>'s responsibility to signal an error, then   hostless pathnames are still useful for merging. Consider: </section>	<pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-merge-pathnames">merge-pathnames</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:NAME</span> <span class="syntax-string">"FRED"</span>)</span> <span class="syntax-interned-symbol">MARY</span>)</span>
</span></code></pre>     This will override both the <a class="glossary-reference" href="../chapter-26.xhtml#glossary-name">name</a> and the HOST field of MARY because you     must currently have a host in every pathname. But if <a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> did     not force the host, or if one could explicitly say :HOST <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>, then     such pathnames would be considerably more useful for merging. <br/></section><section class="status-passed proposal" id="issue-pathname-syntax-error-time:explicitly-vague"><h2 class="section-title">Proposal EXPLICITLY-VAGUE</h2>  Clarify that we were unable to reach agreement on this issue and that   the time at which this error detection occurs is not well-specified. <br/>  Advise the editorial group to warn users clearly about this known source   of program portability problems. <br/><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  This implements the status quo. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>  None. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>  No existing code must be modified, but there is an ongoing cost   associated with providing error checking at multiple points in a   program because implementations disagree as to where an error   might be signalled. In some cases, the effects of having to handle   this in multiple places may cause unpleasant modularity violations. <br/></section></section><section id="section-Test Case" class="section"><h2 class="section-title">Test Case</h2><pre>  See problem description.<br/><br/></pre></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2>  Symbolics Genera signals an error at pathname construction time if a   pathname will be invalid. Once a pathname is successfully constructed,   it can generally be assumed that <a class="function-reference" href="../chapter-19.xhtml#function-namestring">namestring</a> will always succeed. <br/></section><section id="section-Aesthetics" class="section"><h2 class="section-title">Aesthetics</h2>  Making this more well-defined would cause a definite aesthetic   improvement to some programs. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>  Pitman prefers <a class="issue-reference" href="#issue-pathname-syntax-error-time:namestring-coercion">PATHNAME-SYNTAX-ERROR-TIME:NAMESTRING-COERCION</a> but   believes that anything is an improvement over <span class="issue-reference error">issue:...:EXPLICITLY-VAGUE</span>. <br/>  <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> pathname functions were not adequate for use in Macsyma because   they did not adequately represent to-be-merged-only pathnames (a   feature used very extensively in Macsyma), because errors could be   signalled at radically different times. To get around this, Pitman   had to create a data structure in Macsyma called an MPATHNAME which   was only trivially different than a <a class="function-reference" href="../chapter-19.xhtml#function-pathname">pathname</a> but which made it   possible to deal portably with this issue of when errors occurred   and what kinds of errors occured. Unfortunately, since none of the   <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> functions worked on MPATHNAMEs, a whole series of functions,   also only trivially different, had to be created: MAKE-MPATHNAME,   MNAMESTRING, MERGE-MPATHNAMES, MPATHNAME-NAME, MPATHNAME-TYPE,    MOPEN, WITH-MOPEN-FILE, etc. <br/>&mdash;&mdash; Summary of CL-Cleanup discussion: <br/>Most of the mail was endorsements for option <a class="proposal-reference" href="#issue-pathname-syntax-error-time:pathname-creation">PATHNAME-CREATION</a>. Sandra brought up a tangential issue about truenames that eventually became a separate issue. <br/>I think I'm the only person pushing <a class="proposal-reference" href="#issue-pathname-syntax-error-time:namestring-coercion">NAMESTRING-COERCION</a>. I strongly believe it is the right thing, and that <a class="proposal-reference" href="#issue-pathname-syntax-error-time:pathname-creation">PATHNAME-CREATION</a> is suboptimal, based on problems that have struck me with existing <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> pathname system. However, even <a class="proposal-reference" href="#issue-pathname-syntax-error-time:pathname-creation">PATHNAME-CREATION</a> would be an improvement from a portability standpoint and I am probably not going to push it because there are compatibility issues on the side of <a class="proposal-reference" href="#issue-pathname-syntax-error-time:pathname-creation">PATHNAME-CREATION</a> <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">many</span>
<span class="syntax-interned-symbol">implementations</span> <a class="macro-reference" href="../chapter-6.xhtml#macro-do">do</a> <span class="syntax-interned-symbol">this</span> <span class="syntax-interned-symbol">already</span>)</span>
</span></code></pre>, and because there are more important issues for us to spend time on at the meeting. <br/>[Please try to come prepared to vote yes on one or both of  <a class="proposal-reference" href="#issue-pathname-syntax-error-time:pathname-creation">PATHNAME-CREATION</a> or <a class="proposal-reference" href="#issue-pathname-syntax-error-time:namestring-coercion">NAMESTRING-COERCION</a> so we don't have to fall back  on <a class="proposal-reference" href="#issue-pathname-syntax-error-time:explicitly-vague">EXPLICITLY-VAGUE</a>, which is a total loss for program portability.  -kmp] <br/></section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>