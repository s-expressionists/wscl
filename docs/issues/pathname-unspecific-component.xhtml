<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — PATHNAME-UNSPECIFIC-COMPONENT</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">PATHNAME-UNSPECIFIC-COMPONENT</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-pathname-unspecific-component:new-token">Proposal NEW-TOKEN</a><ol> </ol></li><li><a href="#section-Test Case">Test Case</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of Non-Adoption">Cost of Non-Adoption</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Aesthetics">Aesthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue PATHNAME-UNSPECIFIC-COMPONENT [Cleanup] [CHANGE]</h1><h2>Related issues</h2><ul><span class="issue-reference error">issue:PATHNAME-TYPE-UNSPECIFIC</span></ul><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>Accepted, as amended, Jan 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>File System Interface (pp409-427) </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>27-Dec-88, Version 1 by Pitman 17-Mar-89, Version 2 by Masinter (as amended) </section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>  In some file systems, it is inappropriate to represent particular   pathname components, either all the time or in some specialized    circumstance. <br/>   <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Unix pathnames never have a version field. <br/>   <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> In some file systems, specifying a device and a directory means      something very different than specifying the device alone,       particularly when the device is a "logical device" that may      already imply a directory. <br/>   <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Some Unix pathnames have types and others do not. For example,      it is possible to make files named "foo." and "foo" which are      distinct. CLtL <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">p412</span>)</span>
</span></code></pre> specifies that the type is ``always a      string, <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>, or :WILD.'' This description is too restrictive      to be practical in this case. One of these <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">usually</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">former</span>)</span>
</span></code></pre>      can get a type of "" but it is not clear how to represent the      other. If <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a> is used, merging primitives cannot detect that the      field is filled and should not be merged against.  <br/>   <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> ITS pathnames have either a version or a type, but never both.      "JOE;<a class="glossary-reference" href="../chapter-26.xhtml#glossary-file">file</a> 32" has a directory, a name, and a version.      "JOE;<a class="glossary-reference" href="../chapter-26.xhtml#glossary-file">file</a> TEXT" has a directory, a name, and a type.      "JOE;<a class="glossary-reference" href="../chapter-26.xhtml#glossary-file">file</a> TEXT 32" is not a possible ITS filename. <br/></section><section class="status-passed proposal" id="issue-pathname-unspecific-component:new-token"><h2 class="section-title">Proposal NEW-TOKEN</h2>  Permit :UNSPECIFIC as a value of any field of a pathname,   including the HOST, DEVICE, <a class="function-reference" href="../chapter-20.xhtml#function-directory">directory</a>, <a class="glossary-reference" href="../chapter-26.xhtml#glossary-name">name</a>, <a class="symbol-reference" href="../chapter-25.xhtml#symbol-type">type</a>, or   VERSION field of a pathname, for file systems in which it makes sense. <br/>  The results of supplying :UNSPECIFIC to a file system for which   it does not make sense are undefined. <br/>  When a pathname is converted to a namestring, <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a> and :UNSPECIFIC   are treated as if the field were empty. That is, they both cause the   component not to appear in the string. <br/>  When merging, however, only a <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a> value for a component will be   replaced with the default for that component, while :UNSPECIFIC   will be left alone as if the field were filled. <br/>  Portable programs should expect to find :UNSPECIFIC in the device,   directory, type, or version field in some implementations. <br/>  Portable programs should not explicitly place :UNSPECIFIC in any   field, since that it might not be permitted in some situations,   but portable programs may sometimes do so implicitly. <br/></section><section id="section-Test Case" class="section"><h2 class="section-title">Test Case</h2><pre>  ;; #1: Non-portable code. This may signal an error in some<br/>  ;;     implementations where an unspecific type makes no sense.<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-keyword-symbol">:UNSPECIFIC</span>)</span>
</span></code></pre>	;not portable<br/><br/>  ;; #2: In this example, assume a Unix file system.<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-type">pathname-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"foo."</span>)</span>)</span>
</span></code></pre><br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; ""<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-type">pathname-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"foo"</span>)</span>)</span>
</span></code></pre><br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; :UNSPECIFIC<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-type">pathname-type</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-merge-pathnames">merge-pathnames</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"foo"</span>)</span>
				  <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> <span class="syntax-keyword-symbol">:TYPE</span> <span class="syntax-string">"BAR"</span>)</span>)</span>)</span>
</span></code></pre><br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; :UNSPECIFIC<br/><br/>  ;; #3: In this example, assume an ITS file system.<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">P</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"FOO 32"</span>)</span>)</span>)</span>
    <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-type">pathname-type</a> <span class="syntax-interned-symbol">P</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-version">pathname-version</a> <span class="syntax-interned-symbol">P</span>)</span>)</span>)</span>
</span></code></pre><br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:UNSPECIFIC</span> <span class="syntax-number">32</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">P</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"FOO TEXT"</span>)</span>)</span>)</span>
    <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-type">pathname-type</a> <span class="syntax-interned-symbol">P</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-version">pathname-version</a> <span class="syntax-interned-symbol">P</span>)</span>)</span>)</span>
</span></code></pre><br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-string">"TEXT"</span> <span class="syntax-keyword-symbol">:UNSPECIFIC</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">let</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">P</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-merge-pathnames">merge-pathnames</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"FOO 32"</span>)</span>
			    <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"FOO TEXT"</span>)</span>)</span>)</span>)</span>
    <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-type">pathname-type</a> <span class="syntax-interned-symbol">P</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-version">pathname-version</a> <span class="syntax-interned-symbol">P</span>)</span>)</span>)</span>
</span></code></pre><br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:UNSPECIFIC</span> <span class="syntax-number">32</span>)</span>
</span></code></pre><br/><br/>  ;; Note: It is not the intent of this proposal to actually legislate<br/>  ;; the canonical representation of Unix pathnames "foo." and "foo",<br/>  ;; nor of ITS pathnames "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a> 32" and "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a> TEXT". That should probably<br/>  ;; be done, but under separate cover. The above examples are intended<br/>  ;; only to demonstrate how this proposal will permit the representation<br/>  ;; of pathnames not usefully representable under CLtL.<br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  This is, by necessity, current practice in some implementations   already. <br/></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2>  Symbolics Genera uses a file types and versions of :UNSPECIFIC on   Unix and ITS file systems, for example. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>  None. No change to any implementation is forced. <br/>  Some implementations which already do this are legitimized. <br/>  Some implementations which use a non-standard token other than    :UNSPECIFIC to implement this functionality would want to switch   to use :UNSPECIFIC so that portable programs could expect it. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>  Some programs which manipulate pathnames should be updated to expect   :UNSPECIFIC in the type fields in some situations. <br/>  Any program which doesn't already expect :UNSPECIFIC is already not really   portable, however, given that some implementations have been forced to   go beyond the standard in order to represent all possible pathnames. <br/></section><section id="section-Cost of Non-Adoption" class="section"><h2 class="section-title">Cost of Non-Adoption</h2>  Some implementations would be unable to both represent all possible    pathnames in a rational way and at the same time to conform to the   standard. Such an inability would seriously jeopardize the usefulness   of Common Lisp in the design of serious programs. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>  Some programs involving pathnames would be more portable. <br/></section><section id="section-Aesthetics" class="section"><h2 class="section-title">Aesthetics</h2>  Sweeping a hairy situation under the rug doesn't make it go away.   This change makes things appear less simple, but since in reality   they were less simple, it is effectively a simplification of the   correspondence between the <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a> model and reality. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>  Pitman and Moon support <a class="issue-reference" href="#issue-pathname-unspecific-component:new-token">PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN</a>. <br/>  This feature existed <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">for</span> <span class="syntax-interned-symbol">types</span>)</span>
</span></code></pre> in the Colander draft edition of   CLtL, but was removed for the Laser edition. The following text is   excerpted from the Colander edition, p259: <br/>   ``??? Query: Is :unspecific really needed over and above nil? <br/>   ``A component of a pathname can also be the keyword      :UNSPECIFIC. This means that the component has been explicitly      determined not to be there, as opposed to be missing. One way      this can occur is with generic pathnames, which refer not to      a file but to a whole family of files. The version, and usually      the type, of a generic pathname are :unspecific. Another way      :unspecific is used to represent components that are not simply      supported by a file system. When a pathname is converted to a      namestring, nil and :unspecific both cause the component not to      appear in the string. When merging, however, a nil value for      a component will be replaced with the default for that      component, while :unspecific will be left alone.'' <br/>"The stuff about generic pathnames in the discussion section was brain damage and may have lead to the confusion that caused :unspecific to be dropped from Common Lisp.  Only the stuff about components not supported by a file system makes sense." <br/><br/>     &mdash;&ndash; End Forwarded Messages &mdash;&ndash; </section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>