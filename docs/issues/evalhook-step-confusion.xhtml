<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — EVALHOOK-STEP-CONFUSION</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">EVALHOOK-STEP-CONFUSION</span><br/><ol class="local-toc"><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit History">Edit History</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-evalhook-step-confusion:x3j13-nov-89">Proposal X3J13-NOV-89</a><ol> </ol></li><li><a href="#issue-evalhook-step-confusion:fix">Proposal FIX</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Cost to implementors">Cost to implementors</a><ol> </ol></li><li><a href="#section-Cost to users">Cost to users</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue EVALHOOK-STEP-CONFUSION [Cleanup] [CHANGE/CLARIFICATION]</h1><section id="section-References" class="section"><h2 class="section-title">References</h2>CLtL p 321, 323, 441 <a class="issue-reference" href="../issues/step-environment.xhtml#issue-step-environment">X3J13 Issue STEP-ENVIRONMENT</a> (passed) <a class="issue-reference" href="../issues/applyhook-environment.xhtml#issue-applyhook-environment">X3J13 Issue APPLYHOOK-ENVIRONMENT</a> (passed) </section><section id="section-Edit History" class="section"><h2 class="section-title">Edit History</h2>V1, 9 Oct 1989, Sandra Loosemore V2, 2 Nov 1989, Sandra Loosemore (update discussion) V3, 4 Dec 1990, Pitman (amendment per X3J13) </section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>Common Lisp permits the evaluator to be implemented by compiling the form before executing it, but notes that this techniques "renders the EVALHOOK mechanism relatively useless" (CLtL p. 321). <br/>CLtL also requires the <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> utility to be implemented in terms of EVALHOOK <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">p.</span> <span class="syntax-number">323</span>)</span>
</span></code></pre>.  The restriction against implementing <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> using some other technique <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">such</span> <span class="syntax-interned-symbol">as</span> <span class="syntax-interned-symbol">annotations</span> <span class="syntax-interned-symbol">on</span> <span class="syntax-interned-symbol">code</span> <span class="syntax-interned-symbol">lexically</span> <span class="syntax-interned-symbol">within</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a>
<span class="syntax-interned-symbol">body</span> <span class="syntax-interned-symbol">of</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a>)</span>
</span></code></pre> that make more sense in a compiled-only implementation is pointless.  It is probably not even desirable for <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> to be implemented with *EVALHOOK*, since this effectively causes the stepper to break on user programs that also use *EVALHOOK*. <br/></section><section class="status-unknown proposal" id="issue-evalhook-step-confusion:x3j13-nov-89"><h2 class="section-title">Proposal X3J13-NOV-89</h2><ol><li> Remove the requirement that <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> be implemented using *EVALHOOK*. Make it explicitly vague whether the scope of the code that is affected by <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> is lexical or dynamic. <br/></li><li> Delete *EVALHOOK*, *APPLYHOOK*, EVALHOOK, and APPLYHOOK. </li></ol></section><section class="status-unknown proposal" id="issue-evalhook-step-confusion:fix"><h2 class="section-title">Proposal FIX</h2><ol><li> Clarify that there is no guarantee that the functions that are the values of *EVALHOOK* and *APPLYHOOK* will ever be invoked during evaluation. <br/></li><li> Remove the requirement that <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> be implemented using *EVALHOOK*. Make it explicitly vague whether the scope of the code that is affected by <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> is lexical or dynamic. <br/></li><li> Deprecate *EVALHOOK*, *APPLYHOOK*, EVALHOOK, and APPLYHOOK. <br/></li></ol></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>Point by point: <br/><ol><li> This is merely an explicit statement of the status quo. </li><li> This permits compiled-only implementations to support a <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> utility that does something useful. <br/></li><li> The eval hook mechanism is a relic of a particular interpreter implementation technique and really has no place in a language standard, especially since one of the stated goals of the language is consistency between compiled and interpreted code.  Since there is no guarantee that these functions will ever be invoked, portable programs should not rely on them. <br/><br/></li></ol></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2>According to Kent Pitman:   I'm told by the guys who did the Cloe implementation that indeed   neither evalhook nor step do much of anything useful.  If I understood   them correctly, *evalhook* just never gets called, and step works by a   different mechanism that may work at a granularity different than what   people expect. <br/>Loosemore has been implementing an evaluator for Utah Common Lisp that uses a preprocessor to partially compile programs.  The interpreter for the processed code does support the use of an *evalhook*-like special variable, but the information it is passed is in a different format than that which *evalhook* requires.  In particular, the object representing the lexical environment contains only bindings and not syntactic information such as macro definitions.  It also supports a variety of annotation-based program debugging hooks that are specified by declarations.  We are in the process of integrating the preprocessor into the UCL compiler so that most of these debugging hooks will also work in compiled code. <br/></section><section id="section-Cost to implementors" class="section"><h2 class="section-title">Cost to implementors</h2>None. <br/></section><section id="section-Cost to users" class="section"><h2 class="section-title">Cost to users</h2>None. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>Users will not be misled into thinking *evalhook* is more portable than it actually is. <br/>Compiled-only implementations can make <a class="macro-reference" href="../chapter-25.xhtml#macro-step">step</a> do something reasonable. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>There is an article by Parker in Lisp Pointers, Vol 1 #4 which describes one approach for annotation-based debugging.  Loosemore's PhD dissertation (soon to be available as a UofU Tech Report) also discusses alternate approaches for implementing program steppers. <br/>Scott Fahlman says:   I am staying out of most of these discussions, but thought I'd throw in my   two cents' worth on this one: I would very much like to see evalhook and   applyhook removed from the standard.  They have been a constant source of   confusion, and there are so many different interpretations of what these   hooks do that facilities built on top of them are not really very portable   in practice.  I'm now convinced that a really good stepping package cannot   easily be written using these hooks, but must be integrated into the   interpreter of a given implementation. <br/>David Moon says:   Seems okay, except that if we are going to deprecate these things,   I would much rather just remove them.  You would surely argue that   no significant program could possibly be depending on EVALHOOK,   since it has no semantics, so there can't be a compatibility issue.   If we agree that something is a bad idea, I would rather remove it   entirely unless there is a compelling compatibility reason to only   deprecate it.  In fact even if some programs used EVALHOOK, I would   still want to remove it, as I long ago ceased to believe in any   fantasy of seamless compatibility between CLtL and ANSI <a class="package-reference" href="../chapter-11.xhtml#package-cl">cl</a>.  But   others might not agree with me there. <br/>  Plus if we remove them, Symbolics doesn't have to fix the bug that   EVALHOOK and APPLYHOOK accidentally got declared <a class="symbol-reference" href="../chapter-3.xhtml#symbol-special">special</a>.  I mention   this only as an example of the costs of deprecating things instead   of removing them.  They have to be maintained.  Not only do they have   to be documented, but in addition to documenting them we have to tell   people not to use them. <br/>Loosemore says:   I'd rather get rid of these things entirely too, but I have previously   noted some resistance to the idea from others.  Maybe they've changed   their minds by now.  Anyway, if we can't agree to delete them now,    deprecation is better than the current situation. &mdash;&mdash;<a class="function-reference" href="../chapter-12.xhtml#function--">-</a> <br/></section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>