<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp â€” PATHNAME-SUBDIRECTORY-LIST</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">PATHNAME-SUBDIRECTORY-LIST</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-pathname-subdirectory-list:new-representation">Proposal NEW-REPRESENTATION</a><ol> </ol></li><li><a href="#section-Test Cases/Examples">Test Cases/Examples</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of Non-Adoption">Cost of Non-Adoption</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Aesthetics">Aesthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue PATHNAME-SUBDIRECTORY-LIST [NIL] [CHANGE]</h1><h2>Related issues</h2><ul><a class="issue-reference" href="../issues/pathname-component-case.xhtml#issue-pathname-component-case">PATHNAME-COMPONENT-CASE</a><a class="issue-reference" href="../issues/pathname-component-value.xhtml#issue-pathname-component-value">PATHNAME-COMPONENT-VALUE</a></ul><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>passed, as amended, Jun 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>Pathnames (pp410-413), <a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> (p416), <a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> (p417) </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>18-Jun-87, Version 1 by Ghenis.pasa@Xerox.COM 05-Jul-88, Version 2 by Pitman (major revision) 28-Dec-88, Version 3 by Pitman (merge discussion) 22-Mar-89, Version 4 by Moon (fix based on discussion) 19-May-89, Version 5 by Moon (improve based on mail) 21-May-89, Version 6 by Moon (final cleanups) 17-Jun-89, Version 7 by Moon (add current practice and discussion; minor fixes based on discussion) 2-Jul-89, Version 8 by Masinter (add Jun89X3J13 amendment) </section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>  It is impossible to write portable code that can produce a pathname   in a subdirectory of a hierarchical file system. This defeats much of   the purpose of the pathname abstraction. <br/>  According to CLtL, only a string is a portable value for the directory   component of a pathname.  Thus in order to denote a subdirectory, the use   of punctuation characters (such as dots, slashes, or backslashes) would   be necessary. The very fact that such syntax varies from host to host   means that although the representation might be "portable", the code   using that representation is not portable. <br/>  This problem is even worse for programs running on machines on a network   that can retrieve files from multiple hosts, each using a different OS   and thus different subdirectory punctuation. <br/>  Related problems: <br/>  <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> In some implementations "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>.<a class="index/code-reference" href="../chapter-1.xhtml#index/code-bar">bar</a>" might denote the "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-bar">bar</a>" subdirectory     of "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>", while in other implementations it would denote a top-level     directory, because "." is not treated as punctuation. To be safe,     portable programs must avoid all potential punctuation characters. <br/>  <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Even in implementations where "." is used for subdirectories,     "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>.<a class="index/code-reference" href="../chapter-1.xhtml#index/code-bar">bar</a>" may be recognized by some to mean the "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-bar">bar</a>" subdirectory of     "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>" and by others to mean `a seven character directory name with "."     as the fourth character.' <br/>  <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> In fact, CLtL does not even say whether punctuation characters are     part of the string. eg, is "foo" or "/foo" the directory component for     a unix pathname "/foo/bar.lisp". Similarly, is "[<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>]" or "<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>" the     directory component for a VMS pathname "[<a class="index/code-reference" href="../chapter-1.xhtml#index/code-foo">foo</a>]ME.LSP"?     <a class="issue-reference" href="../issues/pathname-component-value.xhtml#issue-pathname-component-value:specify">PATHNAME-COMPONENT-VALUE:SPECIFY</a> says punctuation characters are not     part of the string. <br/></section><section class="status-passed proposal" id="issue-pathname-subdirectory-list:new-representation"><h2 class="section-title">Proposal NEW-REPRESENTATION</h2>  Remove the "structured" directory feature mentioned on CLtL p.412. <br/>  Allow the value of a pathname's directory component to be a list.  The   car of the list is one of the symbols :ABSOLUTE or :RELATIVE.   Each remaining element of the list is a string or a symbol <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">see</span> <span class="syntax-interned-symbol">below</span>)</span>
</span></code></pre>.   Each string names a single level of directory structure.  The strings   should contain only the directory names themselves &ndash; no punctuation   characters. <br/>  A list whose car is the symbol :ABSOLUTE represents a directory path   starting from the root directory.  The list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span>)</span>
</span></code></pre> represents   the root directory.  The list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"foo"</span> <span class="syntax-string">"bar"</span> <span class="syntax-string">"baz"</span>)</span>
</span></code></pre> represents   the directory called "/foo/bar/baz" in Unix [except possibly for   alphabetic case &ndash; that is the subject of a separate issue]. <br/>  A list whose car is the symbol :RELATIVE represents a directory path   starting from a default directory.  The list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:RELATIVE</span>)</span>
</span></code></pre> has the same   meaning as <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a> and hence is not used.  The list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:RELATIVE</span> <span class="syntax-string">"foo"</span> <span class="syntax-string">"bar"</span>)</span>
</span></code></pre>   represents the directory named "bar" in the directory named "foo" in the   default directory. <br/>  In place of a string, at any point in the list, symbols may occur to   indicate special file notations. The following symbols have standard   meanings.  Implementations are permitted to add additional objects of any   non-string type if necessary to represent features of their file systems   that cannot be represented with the standard strings and symbols.   Supplying any non-string, including any of the symbols listed below, to a   file system for which it does not make sense signals an error of type   <a class="type-reference" href="../chapter-20.xhtml#type-file-error">file-error</a>.  For example, Unix does not support :WILD-INFERIORS in   most implementations. <br/>   :WILD           <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Wildcard match of one level of directory structure.    :WILD-INFERIORS <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Wildcard match of any number of directory levels.    :UP             <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Go upward in directory structure <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">semantic</span>)</span>
</span></code></pre>.    :BACK           <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Go upward in directory structure <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">syntactic</span>)</span>
</span></code></pre>. <br/>  :ABSOLUTE or :WILD-INFERIORS immediately followed by :UP or :BACK   signals an error. <br/>  "Syntactic" means that the action of :BACK depends only on the pathname   and not on the contents of the file system.  "Semantic" means that the   action of :UP depends on the contents of the file system; to resolve   a pathname containing :UP to a pathname whose directory component   contains only :ABSOLUTE and strings requires probing the file system.   :UP differs from :BACK only in file systems that support multiple   names for directories, perhaps via symbolic links.  For example,   suppose that there is a directory     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"X"</span> <span class="syntax-string">"Y"</span> <span class="syntax-string">"Z"</span>)</span>
</span></code></pre>   linked to      <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"A"</span> <span class="syntax-string">"B"</span> <span class="syntax-string">"C"</span>)</span>
</span></code></pre>   and there also exist directories     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"A"</span> <span class="syntax-string">"B"</span> <span class="syntax-string">"Q"</span>)</span>
</span></code></pre>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"X"</span> <span class="syntax-string">"Y"</span> <span class="syntax-string">"Q"</span>)</span>
</span></code></pre>   then     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"X"</span> <span class="syntax-string">"Y"</span> <span class="syntax-string">"Z"</span> <span class="syntax-keyword-symbol">:UP</span> <span class="syntax-string">"Q"</span>)</span>
</span></code></pre>   designates     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"A"</span> <span class="syntax-string">"B"</span> <span class="syntax-string">"Q"</span>)</span>
</span></code></pre>   while     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"X"</span> <span class="syntax-string">"Y"</span> <span class="syntax-string">"Z"</span> <span class="syntax-keyword-symbol">:BACK</span> <span class="syntax-string">"Q"</span>)</span>
</span></code></pre>   designates     <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"X"</span> <span class="syntax-string">"Y"</span> <span class="syntax-string">"Q"</span>)</span>
</span></code></pre> <br/>  If a string is used as the value of the :DIRECTORY argument to   <a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a>, it should be the name of a toplevel directory and should   not contain any punctuation characters.  Specifying a string, str, is   equivalent to specifying the list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-interned-symbol">str</span>)</span>
</span></code></pre>.  Specifying the symbol   :WILD is equivalent to specifying the list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-keyword-symbol">:WILD-INFERIORS</span>)</span>
</span></code></pre>,   or <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-keyword-symbol">:WILD</span>)</span>
</span></code></pre> in a file system that does not support :WILD-INFERIORS. <br/>  The <a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> function always returns <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>, :UNSPECIFIC, or a   list, never a string, never :WILD. <br/>  The list returned is not guaranteed to be "freshly consed" &ndash; the   consequences of modifying this list is undefined. <br/>  In non-hierarchical file systems, the only valid list values for the   directory component of a pathname are <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <a class="function-reference" href="../chapter-16.xhtml#function-string">string</a>)</span>
</span></code></pre> and   <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-keyword-symbol">:WILD</span>)</span>
</span></code></pre>.  :RELATIVE directories and the keywords   :WILD-INFERIORS, :UP, and :BACK are not used in non-hierarchical file   systems. <br/>  Pathname merging treats a relative directory specially.  Let   &lt;pathname&gt; and &lt;defaults&gt; be the first two arguments to   <a class="function-reference" href="../chapter-19.xhtml#function-merge-pathnames">merge-pathnames</a>.  If <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;pathname&gt;</span>)</span>
</span></code></pre> is a list whose   car is :RELATIVE, and <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;defaults&gt;</span>)</span>
</span></code></pre> is a list, then   the merged directory is the value of     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-append">append</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;defaults&gt;</span>)</span>
            <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-cdr">cdr</a>  <span class="syntax-line-comment syntax-comment">;remove :RELATIVE from the front
</span>              <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;pathname&gt;</span>)</span>)</span>)</span>
</span></code></pre>   except that if the resulting list contains a string or :WILD immediately   followed by :BACK, both of them are removed.  This removal of redundant   :BACKs is repeated as many times as possible.   If <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;defaults&gt;</span>)</span>
</span></code></pre> is not a list or   <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;pathname&gt;</span>)</span>
</span></code></pre> is not a list whose car is :RELATIVE, the   merged directory is     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-or">or</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;pathname&gt;</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-interned-symbol">&lt;defaults&gt;</span>)</span>)</span>
</span></code></pre> <br/>  A relative directory in the pathname argument to a function such as   <a class="function-reference" href="../chapter-21.xhtml#function-open">open</a> is merged with <a class="variable-reference" href="../chapter-19.xhtml#variable-*default-pathname-defaults*">*default-pathname-defaults*</a> before accessing the   file system. <br/></section><section id="section-Test Cases/Examples" class="section"><h2 class="section-title">Test Cases/Examples</h2><pre>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"[FOO.BAR]BAZ.LSP"</span>)</span>)</span>
</span></code></pre> ;on VMS<br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"FOO"</span> <span class="syntax-string">"BAR"</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"/foo/bar/baz.lisp"</span>)</span>)</span>
</span></code></pre> ;on Unix<br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"foo"</span> <span class="syntax-string">"bar"</span>)</span>
</span></code></pre><br/>  or <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"FOO"</span> <span class="syntax-string">"BAR"</span>)</span>
</span></code></pre><br/>  If <a class="issue-reference" href="../issues/pathname-component-case.xhtml#issue-pathname-component-case:keyword-argument">PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT</a> passes with a default of<br/>  :COMMON, the value is the second one shown.<br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"../baz.lisp"</span>)</span>)</span>
</span></code></pre> ;on Unix<br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:RELATIVE</span> <span class="syntax-keyword-symbol">:UP</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"/foo/bar/../mum/baz"</span>)</span>)</span>
</span></code></pre> ;on Unix<br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"foo"</span> <span class="syntax-string">"bar"</span> <span class="syntax-keyword-symbol">:UP</span> <span class="syntax-string">"mum"</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"&gt;foo&gt;**&gt;bar&gt;baz.lisp"</span>)</span>)</span>
</span></code></pre> ;on LispM<br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"FOO"</span> <span class="syntax-keyword-symbol">:WILD-INFERIORS</span> <span class="syntax-string">"BAR"</span>)</span>
</span></code></pre><br/><br/>  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-19.xhtml#function-parse-namestring">parse-namestring</a> <span class="syntax-string">"&gt;foo&gt;*&gt;bar&gt;baz.lisp"</span>)</span>)</span>
</span></code></pre> ;on LispM<br/>  <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-keyword-symbol">:ABSOLUTE</span> <span class="syntax-string">"FOO"</span> <span class="syntax-keyword-symbol">:WILD</span> <span class="syntax-string">"BAR"</span>)</span>
</span></code></pre><br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>  This would allow programs to deal usefully with hierarchical file   systems, which are by far the most common file system type.   This would allow a system construction utility that organizes programs   by subdirectories to be portable to all implementations that have   hierarchical file systems. <br/>  Discussion indicated that "Implementations are permitted to add   additional objects of any non-string type if necessary to represent   features of their file systems that cannot be represented with the   standard strings and symbols" is a necessary escape hatch for things like   home directories and fancy pattern matching.  Implementations should   limit their use of this loophole and use the standard keyword symbols   whenever that is possible. <br/></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2>  Symbolics Genera implements something very similar to this. The main   differences are:    <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> In Genera, there is no :ABSOLUTE keyword at the head of the list.      This has been shown to cause some problems in dealing with root      directories. Genera represents the root directory by a keyword      symbol <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">rather</span> <span class="syntax-interned-symbol">than</span> <span class="syntax-interned-symbol">a</span> <a class="function-reference" href="../chapter-14.xhtml#function-list">list</a>)</span>
</span></code></pre> because the list representation       was not adequately general.    <a class="function-reference" href="../chapter-12.xhtml#function--">-</a> Genera has no separate concepts of :UP and :BACK.  Genera      represents Unix ".." as :UP, but deals with :UP syntactically, not      semantically. <br/>  On the Explorer, the directory component is a list of strings, not yet   supporting the symbols specified in proposal <a class="issue-reference" href="#issue-pathname-subdirectory-list">pathname-subdirectory-list</a>. <br/>  Macintosh Allegro Common Lisp 1.2.2 uses a string with punctuation   characters instead of a list for the directory. <br/>  Lucid Common Lisp 3.0.1 under Unix uses a list for directories of   somewhat different form from what is proposed in   <a class="issue-reference" href="#issue-pathname-subdirectory-list">pathname-subdirectory-list</a>.  It uses :ROOT instead of :ABSOLUTE and uses   ".." instead of :UP.  It does use :RELATIVE. <br/>  Ibuki Common Lisp Release 01/01 uses a list for directories of somewhat   different form from what is proposed in <a class="issue-reference" href="#issue-pathname-subdirectory-list">pathname-subdirectory-list</a>.  It   uses :ROOT instead of :ABSOLUTE, uses :PARENT instead of :UP, and omits   the leading keyword instead of using :RELATIVE. <br/>  IIM uses a list for directories of somewhat different form from what is   proposed in <a class="issue-reference" href="#issue-pathname-subdirectory-list">pathname-subdirectory-list</a>.  It uses :ABSOLUTE-DIRECTORY   instead of :ABSOLUTE, uses :SUPER-DIRECTORY instead of :BACK, and omits   the leading keyword instead of using :RELATIVE. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>  In principle, nothing about the implementation needs to change except   the treatment of the directory component by <a class="function-reference" href="../chapter-19.xhtml#function-make-pathname">make-pathname</a> and   <a class="function-reference" href="../chapter-19.xhtml#function-pathname-directory">pathname-directory</a>. The internal representation can otherwise be left   as-is if necessary. <br/>  Implementations such as Genera, Explorer, Lucid, Ibuki, and IIM that   already have hierarchical directory handling will have to make an   incompatible change to switch to what is proposed here. <br/>  For implementations that choose to rationalize this representation   throughout their internals and any other implementation-specific   accessors, the cost will be necessarily higher. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>  None for portable programs. This change is upward compatible with CLtL.   Nonportable programs will have to be changed if they use implementation   dependent hierarchical directory handling and the implementation   removes support for that when it adds support for this proposal. <br/></section><section id="section-Cost of Non-Adoption" class="section"><h2 class="section-title">Cost of Non-Adoption</h2>  Serious portability problems would continue to occur. Programmers would be   driven to the use of implementation-specific facilities because the need   for this is frequently impossible to ignore. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>  The serious costs of non-adoption would be avoided. <br/></section><section id="section-Aesthetics" class="section"><h2 class="section-title">Aesthetics</h2>  This representation of hierarchical pathnames is easy to use and quite   general. Users will probably see this as an improvement in the aesthetics. <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>  This issue was raised a while back but no one was fond of the particular   proposal that was submitted. This is an attempt to revive the issue. <br/>  The original proposal, to add a :SUBDIRECTORIES component to a   pathname, was discarded because it imposed an unnatural distinction   between a toplevel directory and its subdirectories. Pitman's guess is   the the idea was to try to make it a compatible change, but since most   programmers will probably want to change from implementation-specific   primitives to portable ones anyway, that's probably not such a big   deal. Also, there could have been some programs which thought the   change was compatible and ended up ignoring important information <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a>
  <span class="syntax-keyword-symbol">:SUBDIRECTORIES</span> <span class="syntax-interned-symbol">component</span>)</span>
</span></code></pre>. Pitman thought it would be better if   people just accepted the cost of an incompatible change in order to   get something really pretty as a result. <br/>  Some people feel it is unnecessary to standardize the format of   pathname components such as the directory. <br/>  Moon doesn't like having both :UP and :BACK, but admits that some   file systems do it one way and some do it the other.  He still thinks   it would be simpler if we got rid of :BACK and just had :UP. <br/>  To keep it simple, we chose not to add to this issue the functions   DIRECTORY-PATHNAME-AS-FILE and PATHNAME-AS-DIRECTORY, which convert   the name of a directory from or to the directory component of a file   inferior to that directory.  This conversion is system-dependent, for   example TOPS-20 appends a type field and Unix does not.  Also in some   systems the root directory has a name and in others it doesn't.  Of   course these functions signal an error in non-hierarchical file   systems.  Examples (for Unix, assuming #P print syntax for pathnames):    (directory-pathname-as-file #P"/usr/bin<a class="function-reference" href="../chapter-12.xhtml#function-/">/</a>sh") <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; #P"/usr/bin"    (pathname-as-directory #P"/usr/bin") <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; #P"/usr/bin"<a class="function-reference" href="../chapter-12.xhtml#function-/">/</a>   These functions have not been proposed because they are mainly useful   in conjunction with additional functions for manipulating directories   (creating, expunging, setting access control) that have not been made   available in Common Lisp. </section></div></main><footer>Copyright Â© 2021 Jan Moringen</footer></body></html>