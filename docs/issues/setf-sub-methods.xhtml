<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp â€” SETF-SUB-METHODS</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">SETF-SUB-METHODS</span><br/><ol class="local-toc"><li><a href="#section-Status">Status</a><ol> </ol></li><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit history">Edit history</a><ol> </ol></li><li><a href="#section-Problem description">Problem description</a><ol> </ol></li><li><a href="#issue-setf-sub-methods:delayed-access-stores">Proposal DELAYED-ACCESS-STORES</a><ol> </ol></li><li><a href="#section-Test Cases">Test Cases</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current Practice">Current Practice</a><ol> </ol></li><li><a href="#section-Performance impact">Performance impact</a><ol> </ol></li><li><a href="#section-Cost to Implementors">Cost to Implementors</a><ol> </ol></li><li><a href="#section-Cost to Users">Cost to Users</a><ol> </ol></li><li><a href="#section-Cost of non-adoption">Cost of non-adoption</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Esthetics">Esthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue SETF-SUB-METHODS [NIL] [CLARIFICATION]</h1><section id="section-Status" class="status-passed section"><h2 class="section-title">Status</h2>Passed, Jan 89 X3J13 </section><section id="section-References" class="section"><h2 class="section-title">References</h2>CLtL pp. 95-96, 99, 105-106, 166 Issue: <a class="issue-reference" href="../issues/push-evaluation-order.xhtml#issue-push-evaluation-order">push-evaluation-order</a> </section><section id="section-Edit history" class="section"><h2 class="section-title">Edit history</h2>Version 1: JonL White &amp; Ken D. Olum 12-Feb-88 (based on problem originally called SETF-METHOD-FOR-SYMBOLS) Version 2: JonL White 23-May-88 (fix references and spellings). Version 3: JonL White 25-May-88  Version 4: JonL White &amp; Ken D. Olum 26-May-88 (final insights!) Version 5: Masinter (respond to comments) <br/></section><section id="section-Problem description" class="section"><h2 class="section-title">Problem description</h2>Implementations differ in the left-to-right order of evaluation in the following form: <br/>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-quote">'<span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-number">1</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-number">2</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-number">3</span>)</span></span>)</span>
</span></code></pre>      <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">s</span> <span class="syntax-interned-symbol">r</span>)</span>
</span></code></pre>      <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span>)</span> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-progn">progn</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span> <span class="syntax-number">6</span>)</span>)</span>
</span></code></pre> <br/>In some implementations, the side-effect of the setq appears to happen before the evaluation of the place form <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span>)</span>
</span></code></pre> which is necessary to fetch the  list being updated.   A typical result is 'r' <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a> <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">B</span> <span class="syntax-number">6</span>)</span>
</span></code></pre>, 's' <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a> <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-number">1</span> <span class="syntax-interned-symbol">B</span> <span class="syntax-number">2</span> <span class="syntax-interned-symbol">C</span> <span class="syntax-number">3</span>)</span>
</span></code></pre> after the operation.  <br/>There is a similar problem with <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a>'s over <a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a>, <a class="function-reference" href="../chapter-12.xhtml#function-mask-field">mask-field</a>, and <a class="index/code-reference" href="../chapter-A.xhtml#index/code-char-bit">char-bit</a>. <br/>CLtL p99 is explicit about left-to-right order of evaluation. However, the specification is less clear about computations involved in "evaluation" of the subforms, and other computations that are implicit in the notion of "doing an access" or "doing a store". <br/></section><section class="status-passed proposal" id="issue-setf-sub-methods:delayed-access-stores"><h2 class="section-title">Proposal DELAYED-ACCESS-STORES</h2>This proposal specifies more explicilty the behavior of <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> in the case   of access forms whose sub-forms are permitted to be generalized variable  references [and which thus need to call GET-SETF-METHOD during setf macro  expansion]. <br/>Remember, first, that GET-SETF-METHOD returns the following: <br/>   &ndash; Some temporary variables    &ndash; A list of value-producing forms    &ndash; A list of store-variables <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">normally</span> <span class="syntax-interned-symbol">one</span>)</span>
</span></code></pre>.    &ndash; A storing form.    &ndash; An accessing form. <br/>The code produced as the macro expansion of a <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> form that itself admits a generalized variable as an argument must essentially do the following major steps: <br/>  ** It evaluates the value-producing sub-forms, in left-to-right order, and       binds the temporary variables to them.  This will be called "binding the       temporaries." <br/>  ** It "reads the value" from the generalized variable using the supplied       accessing form, to get the "old value";  this will be called "doing the      access."  [Note that this is done after all the evaluations of the       preceeding step, including any side-effects they may have.] <br/>  ** It binds the store-variable to a new value, and then installs this      new value into the generalized variable using the supplied "storing       form".   This will be called "doing the store." <br/>"Reading the value" of a generalized variable reference is not part of the series of evaluations  that must be done in left-to-right order.  <br/>The place-specifier forms listed at the top of CLtL p96 permit admit <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">other</span>)</span>
</span></code></pre> place-specifiers as arguments; during the <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> expansion of these forms, it  is necessary to call GET-SETF-METHOD in order to figure out how the inner,  nested generalized variable must be treated.  This proposal requires <a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> be  listed among these forms, since it must have a sub-recursive &lt;place&gt; specifier  [however, there is no Common Lisp function serving as a pseudo-update function for it, the way <a class="function-reference" href="../chapter-12.xhtml#function-dpb">dpb</a> serves for <a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a>].   <br/>For each place-specifier form with a sub-recursive place specifier,   the information from GET-SETF-METHOD is used as follows. <br/>  <a class="index/code-reference" href="../chapter-A.xhtml#index/code-char-bit">char-bit</a>: <br/>    In a form such as: <br/>        <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">CHAR-BIT</span> <span class="syntax-interned-symbol">&lt;place-form&gt;</span> <span class="syntax-interned-symbol">&lt;bit-name&gt;</span>)</span> <span class="syntax-interned-symbol">&lt;value-form&gt;</span>)</span>
</span></code></pre> <br/>    the place referred to by the &lt;place-form&gt; must always be both accessed      and updated; note that the update is to the generalized variable      specified by &lt;place-form&gt; &ndash; not to a character object itself. <br/>    Thus this <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> should generate code to do the following: <br/><ol><li> Bind the temporaries for &lt;place-form&gt; </li><li> Evaluate &lt;bit-name&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">bind</span> <span class="syntax-interned-symbol">into</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">temporary</span>)</span>
</span></code></pre> </li><li> Evaluate &lt;value-form&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">bind</span> <span class="syntax-interned-symbol">into</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">store</span> <a class="symbol-reference" href="../chapter-25.xhtml#symbol-variable">variable</a>)</span>
</span></code></pre> </li><li> Do the access to &lt;place-form&gt; </li><li> Do the store into &lt;place-form&gt;, with the given bit-name of the   character fetched in step 4 changed to reflect the value from step 3. <br/></li></ol>    If the evaluation of &lt;value-form&gt; in step 3 alters what is found in the      given "place" &ndash; such as setting a different "bit" of the character &ndash;     then the change of the bit denoted by &lt;bit-name&gt; will be to that altered     character, because the "access" step is done after the &lt;value-form&gt;     evaluation.  See example 1 in the test cases section.  Nevertheless, the      evaluations required for binding the temporaries are done in steps 1 and      2, and thus the expected left-to-right evaluation order is seen. <br/>  <a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a>:  <br/>    In a form such as: <br/>        <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-interned-symbol">&lt;byte-spec&gt;</span> <span class="syntax-interned-symbol">&lt;place-form&gt;</span>)</span> <span class="syntax-interned-symbol">&lt;value-form&gt;</span>)</span>
</span></code></pre> <br/>    the place referred to by the &lt;place-form&gt; must always be both accessed      and updated;  note that the update is to the generalized variable      specified by &lt;place-form&gt; &ndash; not to any object of type integer. <br/>    Thus this <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> should generate code to do the following: <br/><ol><li> Evaluate &lt;byte-spec&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">bind</span> <span class="syntax-interned-symbol">into</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">temporary</span>)</span>
</span></code></pre> </li><li> Bind the temporaries for &lt;place-form&gt; </li><li> Evaluate &lt;value-form&gt;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">bind</span> <span class="syntax-interned-symbol">into</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">store</span> <a class="symbol-reference" href="../chapter-25.xhtml#symbol-variable">variable</a>)</span>
</span></code></pre> </li><li> Do the access to &lt;place-form&gt; </li><li> Do the store into &lt;place-form&gt; with the given bit-field of the integer  fetched in step 4 replaced with the value from step 3. <br/></li></ol>    If the evaluation of &lt;value-form&gt; in step 3 alters what is found in the      given "place" &ndash; such as setting a different bit-field of the integer &ndash;     then the change of the bit-field denoted by &lt;byte-spec&gt; will be to that      altered integer, because the "access" step is done after the &lt;value-form&gt;     evaluation.  See example 2 in the test cases section.  Nevertheless, the      evaluations required for binding the temporaries are done in steps 1 and      2, and thus the expected left-to-right evaluation order is seen. <br/>  <a class="function-reference" href="../chapter-12.xhtml#function-mask-field">mask-field</a>: <br/>   This case is the same as <a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> in all essential aspects. <br/>  <a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a>: <br/>    In a form such as: <br/>        <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-interned-symbol">&lt;place-form&gt;</span> <span class="syntax-interned-symbol">&lt;ind-form&gt;</span>)</span> <span class="syntax-interned-symbol">&lt;value-form&gt;</span>)</span>
</span></code></pre> <br/>    the place referred to by the &lt;place-form&gt; must always be both accessed      and updated;  note that the update is to the generalized variable      specified by &lt;place-form&gt; &ndash; not necessarily to the particular list     which is the property list in question. <br/>    Thus this <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> should generate code to do the following: <br/><ol><li> Bind the temporaries for &lt;place-form&gt;  </li><li> Evaluate &lt;ind-form&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">bind</span> <span class="syntax-interned-symbol">into</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">temporary</span>)</span>
</span></code></pre> </li><li> Evaluate the &lt;value-form&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-and">and</a> <span class="syntax-interned-symbol">bind</span> <span class="syntax-interned-symbol">into</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <span class="syntax-interned-symbol">store</span> <a class="symbol-reference" href="../chapter-25.xhtml#symbol-variable">variable</a>)</span>
</span></code></pre> </li><li> Do the access to &lt;place-form&gt; </li><li> Do the store into &lt;place-form&gt; with a possibly-new property list  obtained by combining the values from steps 2, 3, and 4.   <br/></li></ol>    If the evaluation of &lt;value-form&gt; in step 3 alters what is found in the      given "place" &ndash; such as setting a different named property in the list,     then the change of the property denoted by &lt;ind-form&gt; will be to that      altered list, because the "access" step is done after the &lt;value-form&gt;     evaluation.  See example 7 in the test cases section.  Nevertheless, the      evaluations required for binding the temporaries are done in steps 1 and      2,  and thus the expected left-to-right evaluation order is seen. <br/>    Note that this phrase "possibly-new property list" treats the      implementation of property lists as a "black box"  &ndash; it can mean that      the former property list is somehow destructively re-used, or it can      mean partial or full copying of it.  This is like the question of <a class="function-reference" href="../chapter-17.xhtml#function-remove">remove</a>     or <a class="function-reference" href="../chapter-17.xhtml#function-delete">delete</a> &ndash; do you copy or do you destructively alter.  Since the answer     could go either way, the treatment of the resultant value for the      "possibly-new property list" must proceed as if it were a different copy     needing to be stored back into the generalized variable. <br/>The "read-modify-write" macros such as <a class="macro-reference" href="../chapter-12.xhtml#macro-incf">incf</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-decf">decf</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-push">push</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pop">pop</a>,  and <a class="macro-reference" href="../chapter-14.xhtml#macro-remf">remf</a>, as well as <a class="macro-reference" href="../chapter-5.xhtml#macro-psetf">psetf</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-shiftf">shiftf</a>, and <a class="macro-reference" href="../chapter-5.xhtml#macro-rotatef">rotatef</a> should be  specified to have the same evalauation order for the subforms of the "place" arguments; this would generally follow from their definition in terms of <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a>. <br/></section><section id="section-Test Cases" class="section"><h2 class="section-title">Test Cases</h2><pre><ol><li> <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <a class="function-reference" href="../chapter-16.xhtml#function-char">char</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">make-char</span> <span class="syntax-character">#\A</span> <span class="syntax-number">1</span>)</span>)</span>
</span></code></pre>         ==&gt;  #\Control-A<br/> <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-rotatef">rotatef</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">char-bit</span> <a class="function-reference" href="../chapter-16.xhtml#function-char">char</a> <span class="syntax-keyword-symbol">:control</span>)</span> 
              <span class="syntax-cons">(<span class="syntax-interned-symbol">char-bit</span> <a class="function-reference" href="../chapter-16.xhtml#function-char">char</a> <span class="syntax-keyword-symbol">:meta</span>)</span>)</span>
</span></code></pre> <br/> char  ==&gt;  #\Meta-A<br/> ;; It's as if you start with #\Control-A, and then first turn the<br/> ;;  :control bit off, because the :meta bit was originally off; and<br/> ;;  then to the resulting #\A,  you add the :meta bit since the<br/> ;;  :control bit was originally on.<br/><br/> Note, however, that if an implementation doesn't support both of these<br/> character 'bits', then this test case would have to be re-written to<br/> reference two independent bits actually supported.  If an implementation<br/> supports fewer than two independent character bits, then this test case<br/> is entirely moot.<br/><br/></li><li> (setq integer #x69)                   ==&gt;  #x69<br/> <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-rotatef">rotatef</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">4</span>)</span> <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a>)</span> 
              <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">0</span>)</span> <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a>)</span>)</span>
</span></code></pre><br/> integer  ==&gt;  #x96<br/> ;; This very-realistic example is simply trying to swap two<br/> ;;  independent bit fields in an integer.  Note that the generalized<br/> ;;  variable of interest here is just the <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">possibly</span> <span class="syntax-interned-symbol">local</span>)</span>
</span></code></pre> program<br/> ;;  variable 'integer'.<br/><br/></li></ol>  3a.(setq l1 (setq l2 (list #x69)))                ==&gt;  (#x69)<br/>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">4</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> <span class="syntax-interned-symbol">l1</span>)</span>)</span>
	   <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">0</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> <span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-prog1">prog1</a> <span class="syntax-interned-symbol">l1</span> 
                                  <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">l1</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span>)</span>)</span>)</span>)</span>
</span></code></pre> <br/>     l1 ==&gt; nil<br/>     l2 ==&gt; (#x99)<br/>     ;; Note that the <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">l1</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span>
</span></code></pre> didn't affect the actions of the setf<br/>     ;;  at all, since l1 was evaluated and its value was saved away in a<br/>     ;;  temporary variable as part of the step "2. Bind the temporaries <br/>     ;;  for &lt;place-form&gt;", and this was done before the evaluation of the<br/>     ;;  &lt;value-form&gt; which contains the <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">l1</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span>
</span></code></pre>.  Note also that the<br/>     ;;  step "4. Do the access to &lt;place-form&gt;" means fetching the <a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> of<br/>     ;;  the saved <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">temporary</span>)</span>
</span></code></pre> value of 'l1'; it does not mean doing a <a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a><br/>     ;;  on anything like that.<br/><br/>  3b.(setq l1 (setq l2 (list #x69)))                ==&gt;  (#x69)<br/>     (setf <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">4</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> <span class="syntax-interned-symbol">l1</span>)</span>)</span>
</span></code></pre><br/>	   (ldb <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">0</span>)</span>
</span></code></pre> (car (rplaca l1 #x17))))<br/>     l1 ==&gt; (#x77)<br/>     l2 ==&gt; (#x77)<br/>     ;; Note that the (rplaca l1 #x17) altered the contents of what l1<br/>     ;;  was pointing to.  Thus even though l1 was evaluated and its  <br/>     ;;  value was saved away in a temporary variable as part of the step <br/>     ;;  "2. Bind the temporaries for &lt;place-form&gt;", and even though this <br/>     ;;  was done before the evaluation of the &lt;value-form&gt; which contains <br/>     ;;  the rplaca, still the side-effect changes things because it alters<br/>     ;;  what will be fetched during the "do the access" step.<br/><br/>  4. (setq integer #x69)<br/>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-mask-field">mask-field</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">4</span>)</span> <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a>)</span> <span class="syntax-cons">(<a class="macro-reference" href="../chapter-12.xhtml#macro-incf">incf</a> <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a>)</span>)</span>
</span></code></pre> <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; #x6A<br/>     integer ==&gt; #x6A<br/><br/>  5. (setq integer #x6A)<br/>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-mask-field">mask-field</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-byte">byte</a> <span class="syntax-number">4</span> <span class="syntax-number">4</span>)</span> <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ash">ash</a> <span class="syntax-cons">(<a class="macro-reference" href="../chapter-12.xhtml#macro-incf">incf</a> <a class="type-reference" href="../chapter-12.xhtml#type-integer">integer</a>)</span> <span class="syntax-number">4</span>)</span>)</span>
</span></code></pre> <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; #x6B0<br/>     integer <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; #xBB<br/><br/>  6. <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">s</span> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">a</span></span> <span class="syntax-number">1</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span> <span class="syntax-number">2</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">c</span></span> <span class="syntax-number">3</span>)</span>)</span>)</span>
</span></code></pre>         ==&gt;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-number">1</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-number">2</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-number">3</span>)</span>
</span></code></pre><br/>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span>)</span> 
           <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-progn">progn</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span> <span class="syntax-number">6</span>)</span>)</span>
</span></code></pre>                   ==&gt;  6<br/>     r ==&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">b</span> <span class="syntax-number">6</span>)</span>
</span></code></pre><br/>     s ==&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-number">1</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-number">2</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-number">3</span>)</span>
</span></code></pre><br/>     ;; Note that the generalized variable of concern here is the <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">degenerate?</span>)</span>
</span></code></pre><br/>     ;;  one of simply the program variable 'r'; it is not a property-list <br/>     ;;  slot denoted by <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span>)</span>
</span></code></pre>.   At the time the step "4. Do the access<br/>     ;;  to &lt;place-form&gt;" is performed, the evaluation of the &lt;value-form&gt;<br/>     ;;  has already altered the generalized variable 'r', and thus a nil is<br/>     ;;  returned for this access; that is why a fresh property-list <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">B</span> <span class="syntax-number">6</span>)</span>
</span></code></pre> is<br/>     ;;  created an stored back into 'r'.<br/><br/>  7. <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">s</span> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">list</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">a</span></span> <span class="syntax-number">1</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span> <span class="syntax-number">2</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">c</span></span> <span class="syntax-number">3</span>)</span>)</span>)</span>)</span>
</span></code></pre>  ==&gt;  <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-number">1</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-number">2</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-number">3</span>)</span>)</span>
</span></code></pre><br/>     <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> <span class="syntax-interned-symbol">r</span>)</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">b</span></span>)</span> 
           <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-progn">progn</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span> <span class="syntax-number">6</span>)</span>)</span>
</span></code></pre>                   ==&gt;  6<br/>     r ==&gt; nil<br/>     s ==&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">A</span> <span class="syntax-number">1</span> <span class="syntax-interned-symbol">B</span> <span class="syntax-number">6</span> <span class="syntax-interned-symbol">C</span> <span class="syntax-number">3</span>)</span>)</span>
</span></code></pre><br/>     ;; Note that the <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">r</span> <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>)</span>
</span></code></pre> does not affect the actions of the setf <br/>     ;;  because the value of R had already been saved in a temporary variable<br/>     ;;  as part of the step "1. Bind the temporaries for &lt;place-form&gt;".  Only<br/>     ;;  the <a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> of this value will be accessed, and subsequently modified <br/>     ;;  after the value computation.<br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>As a principle, <br/>    <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">foo-a</span> <span class="syntax-interned-symbol">x</span>)</span> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-progn">progn</a> <span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">foo-b</span> <span class="syntax-interned-symbol">x</span>)</span> <span class="syntax-interned-symbol">...</span>)</span>
                           <span class="syntax-interned-symbol">new-a-value</span>)</span>)</span>
</span></code></pre> <br/>should always set both of the "slots" of 'x', even if these slots are  implemented as bit-fields, getf-properties, and so on.  Only by separating  out evaluation from "generalized variable access", and by specifying that the access is done after all the evaluations, can this correctly be done. <br/></section><section id="section-Current Practice" class="section"><h2 class="section-title">Current Practice</h2>Lucid Common Lisp already operates pretty much according to this proposal. Symbolics Genera 7.2 foolishly adopted an earlier proposal <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">SETF-METHOD-FOR-SYMBOLS</span>)</span>
</span></code></pre> before it was officially approved by X3J13 and its parent standards organization.  This proposal is incompatible with that one, so Genera 7.2 does not implement the behavior described here, and fails test cases 1, 2, 4, 5, and 6.  Symbolics Genera 7.1 is probably closer to this proposal.  <br/></section><section id="section-Performance impact" class="section"><h2 class="section-title">Performance impact</h2>Small. This proposal might slow down macro-expansion slightly, might cause some current optimizations not to work as well. However, the net effect is likely negligible. <br/></section><section id="section-Cost to Implementors" class="section"><h2 class="section-title">Cost to Implementors</h2>In some implementations, this would require a careful revisiting of the handling of <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> and generalized variable modifiers. <br/></section><section id="section-Cost to Users" class="section"><h2 class="section-title">Cost to Users</h2>Small; although this will impose an incompatible change on  implementations that don't behave as proposed, and might have an effect on <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">non-portable</span>)</span>
</span></code></pre> code, we believe the effects are not widespread. <br/></section><section id="section-Cost of non-adoption" class="section"><h2 class="section-title">Cost of non-adoption</h2><a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> left-to-right order of evaluation will not be well specified; implementations will differ for no good reason. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>Uniform semantics and portability in the face of recursive "place specifiers" for <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a>.  Setf of <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-12.xhtml#function-ldb">ldb</a> <span class="syntax-interned-symbol">...</span> <span class="syntax-interned-symbol">&lt;place&gt;</span>)</span>
</span></code></pre> and of <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> <span class="syntax-interned-symbol">&lt;place&gt;</span> <span class="syntax-interned-symbol">...</span>)</span>
</span></code></pre> will behave uniformly no matter the nature of the &lt;place&gt;. <br/>Anyone who has copied examples from p105 and p106 will continue to be able to use them. <br/></section><section id="section-Esthetics" class="section"><h2 class="section-title">Esthetics</h2>See "Cost of non-adoption" <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>This is a difficult proposal to specify. <br/>In the detailed descriptions for each access form, the phrase     "the place referred to by the &lt;place-form&gt; must always be both       accessed and updated; note that the update is to the generalized       variable specified by &lt;place-form&gt;" is not intended to prevent optimizations that could occur when the code "knows" that the new value will be <a class="function-reference" href="../chapter-5.xhtml#function-eq">eq</a> to the old one.  The only requirements is that the results be semantically equivalent. <br/>There is an interesting parallel between this case for <a class="function-reference" href="../chapter-14.xhtml#function-getf">getf</a> and the very common mistake made by Lisp programmers with respect to the  function <a class="function-reference" href="../chapter-17.xhtml#function-delete">delete</a>.  How often the complaint is filed that <a class="function-reference" href="../chapter-17.xhtml#function-delete">delete</a> didn't do anything when it should have; but in fact the filer simply forgot that delete, although permitted to destructively modify the original list, may also return some tail of the list originally give it,  whether or not an alteration occurs. <br/>      <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">setq</a> <span class="syntax-interned-symbol">l</span> <span class="syntax-quote">'<span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-interned-symbol">d</span>)</span></span>)</span>
</span></code></pre> ==&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-interned-symbol">d</span>)</span>
</span></code></pre>       <pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-17.xhtml#function-delete">delete</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">a</span></span> <span class="syntax-interned-symbol">l</span>)</span>
</span></code></pre>         ==&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">b</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-interned-symbol">d</span>)</span>
</span></code></pre>       l 		    ==&gt; <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">b</span> <span class="syntax-interned-symbol">c</span> <span class="syntax-interned-symbol">d</span>)</span>
</span></code></pre> <br/>The unwary user thinks that because 'l' is still <a class="function-reference" href="../chapter-5.xhtml#function-eq">eq</a> to the original value  that "<a class="function-reference" href="../chapter-17.xhtml#function-delete">delete</a> didn't do anything".  The temptation to ignore the resultant  value of <a class="function-reference" href="../chapter-17.xhtml#function-delete">delete</a> parallels the temptation to forget about a need to perform a final update to &lt;place-form&gt; in the setf-of-getf case. <br/>In the <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">degenerate?</span>)</span>
</span></code></pre> case when a generalized variable  is in fact simply a program variable, then there are no sub-forms to be considered "value-producing" forms; in fact, "doing the access" for such a generalized variable <pre><code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">i.e.</span> <span class="syntax-interned-symbol">a</span> <span class="syntax-interned-symbol">program</span> <a class="symbol-reference" href="../chapter-25.xhtml#symbol-variable">variable</a>)</span>
</span></code></pre> is functionally the same as evaluating it.  This explains why the behaviour in the "Problem  Description" is at first perplexing &ndash; the "do the access" step has the same semantics as an evaluation step, even though it is done after all the prescribed evaluations. <br/>The <a class="issue-reference" href="../issues/push-evaluation-order.xhtml#issue-push-evaluation-order">X3J13 Issue PUSH-EVALUATION-ORDER</a> is a clarification about just the point of the evaluation order for the various subforms to a <a class="macro-reference" href="../chapter-14.xhtml#macro-push">push</a>;  thus there is a similarity to this issue, but the present issue has a much deeper problem because of the need to call GET-SETF-METHOD during setf macro expansion. </section></div></main><footer>Copyright Â© 2021 Jan Moringen</footer></body></html>