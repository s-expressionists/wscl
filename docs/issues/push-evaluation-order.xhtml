<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
  "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="../style.css"/><script src="../permalink.js"/><script src="../navigation.js"/><title>Well-specified Common Lisp — PUSH-EVALUATION-ORDER</title></head><body><main><nav class="sidebar"><span class="name">Entry Points</span><br/><ol><li><a href="../chap-0.xhtml#section-Figures">Table of Contents</a></li><li><a href="../symbol-index.xhtml#section-SymbolIndex">Symbol Index</a></li><li><a href="../figure-index.xhtml#section-FigureIndex">Figure Index</a></li><li><a href="../issue-index.xhtml#section-IssueIndices">Issue Index</a></li><li><a href="../note-indices.xhtml#section-ReviewerNoteIndex">Note Indices</a></li><li><a href="../chapter-26.xhtml#section-Glossary">Glossary</a></li></ol><hr/><span class="name">PUSH-EVALUATION-ORDER</span><br/><ol class="local-toc"><li><a href="#section-References">References</a><ol> </ol></li><li><a href="#section-Edit History">Edit History</a><ol> </ol></li><li><a href="#section-Problem Description">Problem Description</a><ol> </ol></li><li><a href="#issue-push-evaluation-order:item-first">Proposal ITEM-FIRST</a><ol> </ol></li><li><a href="#section-Examples">Examples</a><ol> </ol></li><li><a href="#section-Rationale">Rationale</a><ol> </ol></li><li><a href="#section-Current practice">Current practice</a><ol> </ol></li><li><a href="#section-Cost to implementors">Cost to implementors</a><ol> </ol></li><li><a href="#section-Cost to users">Cost to users</a><ol> </ol></li><li><a href="#section-Benefits">Benefits</a><ol> </ol></li><li><a href="#section-Esthetics">Esthetics</a><ol> </ol></li><li><a href="#section-Discussion">Discussion</a><ol> </ol></li><li><a href="#section-Note that DEFINE-SETF-METHOD is immune to the exception specified about DEFMACRO and DEFINE-SETF-METHOD, because since CLtL p.103 says about DEFINE-SETF-METHOD">Note that DEFINE-SETF-METHOD is immune to the exception specified about DEFMACRO and DEFINE-SETF-METHOD, because since CLtL p.103 says about DEFINE-SETF-METHOD</a><ol> </ol></li></ol></nav><div class="content"><h1>X3J13 Issue PUSH-EVALUATION-ORDER [NIL] [CLARIFICATION]</h1><section id="section-References" class="section"><h2 class="section-title">References</h2>CLtL p. 99 (generalized variables) p. 270 (<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a>) All macros that manipulate generalized variables (<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-psetf">PSETF</a>, <a class="function-reference" href="../chapter-14.xhtml#function-getf">GETF</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-remf">REMF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-incf">INCF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-decf">DECF</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pushnew">PUSHNEW</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pop">POP</a>, <a class="macro-reference" href="../chapter-9.xhtml#macro-check-type">CHECK-TYPE</a>, <a class="macro-reference" href="../chapter-9.xhtml#macro-assert">ASSERT</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-ctypecase">CTYPECASE</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-ccase">CCASE</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-shiftf">SHIFTF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-rotatef">ROTATEF</a>, and all macros defined by <a class="macro-reference" href="../chapter-5.xhtml#macro-define-modify-macro">DEFINE-MODIFY-MACRO</a>). <span class="issue-reference error">issue:SETF-FUNCTION-VS-MACRO</span>. </section><section id="section-Edit History" class="section"><h2 class="section-title">Edit History</h2>Version 1, 15-Oct-87, Jeff Peck Version 2, 23-Oct-87, Larry Masinter Version 3, 8-Nov-87, David Moon  Version 4, 14-Nov-87, Larry Masinter  Version 5, 25-Nov-87, Larry Masinter </section><section id="section-Problem Description" class="section"><h2 class="section-title">Problem Description</h2>In the form <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">ref1</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">CAR</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">ref2</span>)</span>)</span>)</span>
</span></code> It is unclear whether <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">ref1</span>)</span>
</span></code> should be evaluated before <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">ref2</span>)</span>
</span></code>.  <br/>CLtL, page 99, in a discussion of generalized variable macros, states:  <br/>"Macros that manipulate generalized variables must guarantee the `obvious' semantics: subforms of generalized-variable references are evaluated ... in exactly the same order as they appear in the *source* program. The expansion of these macros must consist of code that follows these rules or has the same effect as such code.  This is accomplished by introducing temporary variables bound to the subforms of the reference." <br/>This paragraph and a discussion of <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> on the previous pages may also be interpreted as requiring that *all* subforms of such macro calls should be evaluated once, in source order, left to right. <br/>However, CLtL, page 270 states: <br/>"The effect of (<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> Item Place) is roughly equivalent to <br/>    (<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> Place (<a class="function-reference" href="../chapter-14.xhtml#function-cons">CONS</a> Item Place)) <br/>except that the latter would evaluate any subforms of Place twice while <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> takes care to evaluate them only once." <br/>Place and Item appear in different order in the <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> form and the indicated equivalent <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> form.  Should the <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> form have primacy over the obvious <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> form with respect to the left-to-right evaluation? <br/>Are all subforms in a macro call guaranteed to be evaluated in order, or only those subforms representing generalized variable references? <br/>The same question arises for other forms which manipulate generalized variables, e.g., <a class="macro-reference" href="../chapter-14.xhtml#macro-pushnew">PUSHNEW</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-incf">INCF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-decf">DECF</a>, and those defined with <a class="macro-reference" href="../chapter-5.xhtml#macro-define-modify-macro">DEFINE-MODIFY-MACRO</a>. <br/></section><section class="status-unknown proposal" id="issue-push-evaluation-order:item-first"><h2 class="section-title">Proposal ITEM-FIRST</h2>This proposal is hard to state, although the intent is fairly clear: evalution proceeds from left to right whenever possible. The left-to-right rule does not remove the obligation on writers of macros and define-setf-method  to ensure left-to-right order, however.  <br/>In this proposal, a form is something whose syntactic use is such that it will be evaluated. A "subform" means a form that is nested inside another form &ndash; not any object nested inside a form regardless of syntactic context.  <br/><ol><li> The evaluation ordering of subforms within a generalized variable reference is determined by the order specified by the second value returned by GET-SETF-METHOD. For all predefined generalized variable references (<a class="function-reference" href="../chapter-14.xhtml#function-getf">GETF</a>, <a class="function-reference" href="../chapter-12.xhtml#function-ldb">LDB</a>), this order of evaluation is exactly left-to-right. When a generalized variable reference is derived from a macro expansion, this rule is applied *after* the macro is expanded to find the appropriate generalized variable reference.  This is intended to make it clear that if the user writes a <a class="macro-reference" href="../chapter-3.xhtml#macro-defmacro">DEFMACRO</a> or DEFINE-SETF-METHOD that doesn't preserve order, the the order specified in the user's code holds; e.g., given    <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-3.xhtml#macro-defmacro">DEFMACRO</a> <span class="syntax-interned-symbol">WRONG-ORDER</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">X</span> <span class="syntax-interned-symbol">Y</span>)</span> <span class="syntax-quasiquote">`<span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-getf">GETF</a> <span class="syntax-unquote">,<span class="syntax-interned-symbol">Y</span></span> <span class="syntax-unquote">,<span class="syntax-interned-symbol">X</span></span>)</span></span>)</span>
</span></code>  that <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> <span class="syntax-interned-symbol">&lt;value&gt;</span> <span class="syntax-cons">(<span class="syntax-interned-symbol">WRONG-ORDER</span> <span class="syntax-interned-symbol">&lt;place1&gt;</span> <span class="syntax-interned-symbol">&lt;place2&gt;</span>)</span>)</span>
</span></code>. <br/>will evaluate &lt;place2&gt; first and then &lt;place1&gt; because that is the order they are evaluated in the macro expansion. <br/></li><li> For the macros that manipulate generalized variables (<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pushnew">PUSHNEW</a>, <a class="function-reference" href="../chapter-14.xhtml#function-getf">GETF</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-remf">REMF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-incf">INCF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-decf">DECF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-shiftf">SHIFTF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-rotatef">ROTATEF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-psetf">PSETF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pop">POP</a>, and those defined with <a class="macro-reference" href="../chapter-5.xhtml#macro-define-modify-macro">DEFINE-MODIFY-MACRO</a>) the subforms of the macro call are evaluated exactly once in left to right order, with the subforms of the generalized variable references evaluted in the order specified in <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-number">1</span>)</span>
</span></code>. <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pushnew">PUSHNEW</a>, <a class="function-reference" href="../chapter-14.xhtml#function-getf">GETF</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-remf">REMF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-incf">INCF</a>, <a class="macro-reference" href="../chapter-12.xhtml#macro-decf">DECF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-shiftf">SHIFTF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-rotatef">ROTATEF</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-psetf">PSETF</a>, <a class="macro-reference" href="../chapter-14.xhtml#macro-pop">POP</a> evaluate all subforms before modifying any of the generalized variable locations. <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">in</span> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-case">case</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-when">when</a> <a class="special-operator-reference" href="../chapter-3.xhtml#special-operator-the">the</a> <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> <span class="syntax-interned-symbol">macro</span> <span class="syntax-interned-symbol">has</span> <span class="syntax-interned-symbol">more</span> <span class="syntax-interned-symbol">than</span> <span class="syntax-interned-symbol">two</span> <span class="syntax-interned-symbol">arguments</span>)</span>
</span></code> performs its operation on each pair in sequence, i.e., in <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> <span class="syntax-interned-symbol">&lt;place1&gt;</span> <span class="syntax-interned-symbol">&lt;value1&gt;</span> <span class="syntax-interned-symbol">&lt;place2&gt;</span> <span class="syntax-interned-symbol">&lt;value2&gt;</span> <span class="syntax-interned-symbol">...</span>)</span>
</span></code>, the subforms of &lt;place1&gt; and &lt;value1&gt; are evaluated, the location specified by &lt;place1&gt; is modified to contain the value returned by &lt;value1&gt;, and then the rest of the <a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> form is processed in a like manner. <br/></li><li> For the macros <a class="macro-reference" href="../chapter-9.xhtml#macro-check-type">CHECK-TYPE</a>, <a class="macro-reference" href="../chapter-5.xhtml#macro-ctypecase">CTYPECASE</a>, and <a class="macro-reference" href="../chapter-5.xhtml#macro-ccase">CCASE</a>, subforms of the generalized variable reference are evaluted once as in <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-number">1</span>)</span>
</span></code>, but may be evaluted again if the type check files in the case of <a class="macro-reference" href="../chapter-9.xhtml#macro-check-type">CHECK-TYPE</a> or none of the cases hold in <a class="macro-reference" href="../chapter-5.xhtml#macro-ctypecase">CTYPECASE</a> and <a class="macro-reference" href="../chapter-5.xhtml#macro-ccase">CCASE</a>. </li><li> For the macro <a class="macro-reference" href="../chapter-9.xhtml#macro-assert">ASSERT</a>, the order of evaluation of the generalized variable references is not specified.   (Rules 2, 3 and 4 cover all macros defined in Common Lisp that manupulate generalized variable references.) <br/></li></ol></section><section id="section-Examples" class="section"><h2 class="section-title">Examples</h2><pre><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">LET</a> <span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">REF2</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">LIST</a> <span class="syntax-quote">'<span class="syntax-symbol">()</span></span>)</span>)</span>)</span>
 <span class="syntax-cons">(<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-progn">PROGN</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-22.xhtml#function-princ">PRINC</a> <span class="syntax-string">"1"</span>)</span> <span class="syntax-quote">'<span class="syntax-interned-symbol">REF-1</span></span>)</span>
       <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">CAR</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-progn">PROGN</a> <span class="syntax-cons">(<a class="function-reference" href="../chapter-22.xhtml#function-princ">PRINC</a> <span class="syntax-string">"2"</span>)</span> <span class="syntax-interned-symbol">REF2</span>)</span>)</span>)</span>)</span>
</span></code></pre><br/><br/>Under this proposal, this would be required to print 12 and not 21.<br/><br/><pre><code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let">LET</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">X</span>)</span>
   <span class="syntax-cons">(<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">SETQ</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">LIST</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">A</span></span>)</span>)</span>
         <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">CAR</a> <span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">SETQ</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">LIST</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">B</span></span>)</span>)</span>)</span>)</span>
    <span class="syntax-interned-symbol">X</span>)</span>
</span></code></pre><br/><br/>; the <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> first evalutes <code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">SETQ</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">LIST</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">A</span></span>)</span>)</span>
</span></code> <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt;  <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">A</span>)</span>
</span></code><br/>; then evaluates <code><span class="syntax-root"><span class="syntax-cons">(<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-setq">SETQ</a> <span class="syntax-interned-symbol">X</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-list">LIST</a> <span class="syntax-quote">'<span class="syntax-interned-symbol">B</span></span>)</span>)</span>
</span></code> <a class="function-reference" href="../chapter-12.xhtml#function-=">=</a>&gt; <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">B</span>)</span>
</span></code><br/>; then modifies the <a class="function-reference" href="../chapter-14.xhtml#function-car">CAR</a> of <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">this</span> <span class="syntax-interned-symbol">latest</span> <span class="syntax-interned-symbol">value</span>)</span>
</span></code> to be <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">A</span>)</span> <span class="syntax-symbol">.</span> <span class="syntax-interned-symbol">B</span>)</span>
</span></code>.<br/>; The result is <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-cons">(<span class="syntax-interned-symbol">A</span>)</span> <span class="syntax-symbol">.</span> <span class="syntax-interned-symbol">B</span>)</span>)</span>
</span></code>. <br/><br/>Documentation impact:<br/><br/><a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> should more appropriately be described as:<br/><br/>"(<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> Item Place) is roughly equivalent to (<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">SETF</a> Place (<a class="function-reference" href="../chapter-14.xhtml#function-cons">CONS</a> Item Place)) except that the subforms of Place are evaluated only once, and Item is evaluated before Place."<br/><br/>The phase "subforms of the reference" which appears several times in CLtL should be made more specific to be "subforms of the macro call," referring to the entire form that calls the generalized-variable manipulating macro.<br/><br/></pre></section><section id="section-Rationale" class="section"><h2 class="section-title">Rationale</h2>This is the unstated intention of the page 97-100 discussion of generalized-variable referencing macros, and indeed the intended definition of "obvious semantics" for all macros. <br/></section><section id="section-Current practice" class="section"><h2 class="section-title">Current practice</h2>Many implementations do not currently follow this evaluation order. In the form (<a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place then Item. Symbolics evaluates Item then Place. <br/>For example, in Franz: <br/><code><span class="syntax-root"><span class="syntax-cons">(<a class="function-reference" href="../chapter-3.xhtml#function-macroexpand">macroexpand</a> <span class="syntax-quote">'<span class="syntax-cons">(<a class="macro-reference" href="../chapter-14.xhtml#macro-push">push</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">ref1</span>)</span> <span class="syntax-cons">(<a class="function-reference" href="../chapter-14.xhtml#function-car">car</a> <span class="syntax-cons">(<span class="syntax-interned-symbol">ref2</span>)</span>)</span>)</span></span>)</span>
</span></code> <br/>    (<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">LET*</a> ((#:G8 <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">REF2</span>)</span>
</span></code>)            (#:G7 (<a class="function-reference" href="../chapter-14.xhtml#function-cons">CONS</a> <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">REF1</span>)</span>
</span></code> (<a class="function-reference" href="../chapter-14.xhtml#function-car">CAR</a> #:G8))))       (EXCL::.INV-CAR #:G8 #:G7))  <br/>In Symbolics Common Lisp, it returns: <br/>    (<a class="special-operator-reference" href="../chapter-5.xhtml#special-operator-let*">LET*</a> ((#:G5 <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">REF1</span>)</span>
</span></code>)            (#:G4 <code><span class="syntax-root"><span class="syntax-cons">(<span class="syntax-interned-symbol">REF2</span>)</span>
</span></code>))       <a class="section-reference" href="../chapter-1.xhtml#section-NIL">NIL</a>       (<span class="issue-reference error">issue:SYS</span> #:G4 (<a class="function-reference" href="../chapter-5.xhtml#function-values">VALUES</a> (<a class="function-reference" href="../chapter-14.xhtml#function-cons">CONS</a> #:G5 (<a class="function-reference" href="../chapter-14.xhtml#function-car">CAR</a> #:G4))))) <br/></section><section id="section-Cost to implementors" class="section"><h2 class="section-title">Cost to implementors</h2>Minimal, <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> etc. could simply be defined by the appropriate macros. <br/></section><section id="section-Cost to users" class="section"><h2 class="section-title">Cost to users</h2>No currently portable program should be affected. However, this is a minor incompatible change for some implementations. No serious performance impact is expected; while some macro expansions may appear to be more verbose, most compilers deal reasonably with the required order of evaluation. <br/></section><section id="section-Benefits" class="section"><h2 class="section-title">Benefits</h2>The implementation and semantics of <a class="macro-reference" href="../chapter-14.xhtml#macro-push">PUSH</a> become more well specified. This removes a source of non-portability, abeit likely rare. <br/></section><section id="section-Esthetics" class="section"><h2 class="section-title">Esthetics</h2>Common Lisp defines order of evaluation as left-to-right; this clarification ensures consistency across the language.  <br/></section><section id="section-Discussion" class="section"><h2 class="section-title">Discussion</h2>This seems to be the intent of most of the relevant language in CLtL. <br/>For example, the second to last paragraph on page 99 <br/>"As an example of these semantic rules, in the generalized-variable reference <code><span class="syntax-root"><span class="syntax-cons">(<a class="macro-reference" href="../chapter-5.xhtml#macro-setf">setf</a> <span class="syntax-interned-symbol">reference</span> <span class="syntax-interned-symbol">value</span>)</span>
</span></code>, the value form must be evaluated after all the subforms of the reference because the value form appears to the right of them." <br/>makes it clear that in this context the phrase "generalized-variable reference" was meant to refer to the entire macro call, not just the Place, and that order of evaluation rules are not limited to subforms of Places.  We hope the specification should adopt more consistent terminology. <br/></section><section id="section-Note that DEFINE-SETF-METHOD is immune to the exception specified about DEFMACRO and DEFINE-SETF-METHOD, because since CLtL p.103 says about DEFINE-SETF-METHOD" class="section"><h2 class="section-title">Note that DEFINE-SETF-METHOD is immune to the exception specified about DEFMACRO and DEFINE-SETF-METHOD, because since CLtL p.103 says about DEFINE-SETF-METHOD</h2>"This binding permits the body forms to be written without regard for order-of-evaluation issues." <br/></section></div></main><footer>Copyright © 2021 Jan Moringen</footer></body></html>