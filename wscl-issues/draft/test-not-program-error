Issue:          TEST-NOT-PROGRAM-ERROR
Forum:          Cleanup
Category:       CLARIFICATION
Status:         draft
Edit History:   03-Sep-21, Version 1 by Tarn W. Burton
References:     ADJOIN, ASSOC, COUNT, FIND, INTERSECTION, NINTERSECTION,
                MEMBER, MISMATCH, POSITION, RASSOC, REMOVE, DELETE,
                REMOVE-DUPLICATES, DELETE-DUPLICATES, SEARCH,
                SET-DIFFERENCE, NSET-DIFFERENCE, SET-EXCLUSIVE-OR,
                NSET-EXCLUSIVE-OR, SUBLIS, NSUBLIS, SUBSETP, SUBST,
                NSUBST, SUBSTITUTE, NSUBSTITUTE, TREE-EQUAL, UNION,
                NUNION
Related Issues: TEST-NOT-IF-NOT

Problem Description:

  In section 17.2.1 "Satisfying a Two-Argument Test" of the draft
  ANSI Common Lisp specification it is stated that the consequences
  are unspecified if both the :TEST and the :TEST-NOT keys are
  supplied to the operators that permit these keys.

Proposal (TEST-NOT-PROGRAM-ERROR:SIGNAL-ERROR-IN-SAFE-CODE):

  This proposal updates the specification text to indicate that
  a PROGRAM-ERROR will be signaled if both keys are supplied.
  The individual proposed changes are:

  1. Update section 17.2.1 by replacing "The consequences are
     unspecified if both a :test and a :test-not argument are
     supplied in the same call to F." with "If both a :test and
     a :test-not argument are supplied in the same call to F then
     a program-error will be signaled."

  2. Add the following sentence to "Exceptional Situations" for
     each one of the functions listed in References: "If both
     a :test and a :test-not argument are supplied then a
     program-error will be signaled."

Test Cases:

  (defun adjoin/t ()
    (adjoin 1 '(1 2 3) :test #'eql :test-not #'eql))

  (defun assoc/t ()
    (assoc 1 '((1 . a) (2 . b) (3 . c)) :test #'eql :test-not #'eql))

  (defun count/t ()
    (count 1 '(1 2 3) :test #'eql :test-not #'eql))

  (defun find/t ()
    (find 1 '(1 2 3) :test #'eql :test-not #'eql))

  (defun intersection/t ()
    (intersection '(1 2 3) '(3 4 5) :test #'eql :test-not #'eql))

  (defun nintersection/t ()
    (nintersection (list 1 2 3) (list 3 4 5) :test #'eql :test-not #'eql))

  (defun member/t ()
    (member 1 '(1 2 3) :test #'eql :test-not #'eql))

  (defun mismatch/t ()
    (mismatch '((1 . a) (2 . b) (3 . c)) '(1 2 3) :test #'eql :test-not #'eql))

  (defun position/t ()
    (position 1 '(1 2 3) :test #'eql :test-not #'eql))

  (defun rassoc/t ()
    (rassoc 1 '((1 . a) (2 . b) (3 . c)) :test #'eql :test-not #'eql))

  (defun remove/t ()
    (remove 1 '(1 2 3) :test #'eql :test-not #'eql))

  (defun delete/t ()
    (delete 1 (list 1 2 3) :test #'eql :test-not #'eql))

  (defun remove-duplicates/t ()
    (remove-duplicates '(1 2 1 3) :test #'eql :test-not #'eql))

  (defun delete-duplicates/t ()
    (delete-duplicates (list 1 2 1 3) :test #'eql :test-not #'eql))

  (defun search/t ()
    (search '(1 2) '(1 2 3) :test #'eql :test-not #'eql))

  (defun set-difference/t ()
    (set-difference '(1 2 3) '(3 4 5) :test #'eql :test-not #'eql))

  (defun nset-difference/t ()
    (nset-difference (list 1 2 3) (list 3 4 5) :test #'eql :test-not #'eql))

  (defun set-exclusive-or/t ()
    (set-exclusive-or '(1 2 3) '(3 4 5) :test #'eql :test-not #'eql))

  (defun nset-exclusive-or/t ()
    (nset-exclusive-or (list 1 2 3) (list 3 4 5) :test #'eql :test-not #'eql))

  (defun sublis/t ()
    (sublis '((1 . a) (2 . b) (3 . c)) '(1 2 3) :test #'eql :test-not #'eql))

  (defun nsublis/t ()
    (sublis '((1 . a) (2 . b) (3 . c)) (list 1 2 3) :test #'eql :test-not #'eql))

  (defun subsetp/t ()
    (subsetp '(2 3) '(1 2 3) :test #'eql :test-not #'eql))

  (defun subst/t ()
    (subst 1 2 '(1 2 3) :test #'eql :test-not #'eql))

  (defun nsubst/t ()
    (nsubst 1 2 (list 1 2 3) :test #'eql :test-not #'eql))

  (defun substitute/t ()
    (substitute 1 2 '(1 2 3) :test #'eql :test-not #'eql))

  (defun nsubstitute/t ()
    (nsubstitute 1 2 (list 1 2 3) :test #'eql :test-not #'eql))

  (defun tree-equal/t ()
    (subsetp '(2 3) '(1 2 3) :test #'eql :test-not #'eql))

  (defun union/t ()
    (union '(1 2 3) '(3 4 5) :test #'eql :test-not #'eql))

  (defun nunion/t ()
    (nunion (list 1 2 3) (list 3 4 5) :test #'eql :test-not #'eql))

  (adjoin/t) ; => [signals PROGRAM-ERROR]
  (assoc/t) ; => [signals PROGRAM-ERROR]
  (count/t) ; => [signals PROGRAM-ERROR]
  (find/t) ; => [signals PROGRAM-ERROR]
  (intersection/t) ; => [signals PROGRAM-ERROR]
  (nintersection/t) ; => [signals PROGRAM-ERROR]
  (member/t) ; => [signals PROGRAM-ERROR]
  (mismatch/t) ; => [signals PROGRAM-ERROR]
  (position/t) ; => [signals PROGRAM-ERROR]
  (rassoc/t) ; => [signals PROGRAM-ERROR]
  (remove/t) ; => [signals PROGRAM-ERROR]
  (delete/t) ; => [signals PROGRAM-ERROR]
  (remove-duplicates/t) ; => [signals PROGRAM-ERROR]
  (delete-duplicates/t) ; => [signals PROGRAM-ERROR]
  (search/t) ; => [signals PROGRAM-ERROR]
  (set-difference/t) ; => [signals PROGRAM-ERROR]
  (nset-difference/t) ; => [signals PROGRAM-ERROR]
  (set-exclusive-or/t) ; => [signals PROGRAM-ERROR]
  (nset-exclusive-or/t) ; => [signals PROGRAM-ERROR]
  (sublis/t) ; => [signals PROGRAM-ERROR]
  (nsublis/t) ; => [signals PROGRAM-ERROR]
  (subsetp/t) ; => [signals PROGRAM-ERROR]
  (subst/t) ; => [signals PROGRAM-ERROR]
  (nsubst/t) ; => [signals PROGRAM-ERROR]
  (substitute/t) ; => [signals PROGRAM-ERROR]
  (nsubstitute/t) ; => [signals PROGRAM-ERROR]
  (tree-equal/t) ; => [signals PROGRAM-ERROR]
  (union/t) ; => [signals PROGRAM-ERROR]
  (nunion/t) ; => [signals PROGRAM-ERROR]

Rationale:

  X3J13 cleanup deprecated but did not remove the :test-not
  key. Supplying both keys is a contradition and although
  the draft ANSI specification states that consequences are
  unspecified most implementations are actually signalling
  an error for the majority of the affected operators.

Current Practice:

Cost to Implementors:

  Very small.  Many of the functions listed in References are
  already signalling an error.

Cost to Users:

  None.

Cost of non-adoption:

  TODO

Benefits:

  TODO

Aesthetics:

  TODO

Discussion:

  TODO
