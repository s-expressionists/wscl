Issue:          FILL-POINTER-VALID-FILL-POINTER
Forum:          Cleanup
Category:       CLEANUP
Status:         draft
Edit History:   03-Mar-24, Version 1 by Robert Strandh,
References:     FILL-POINTER

Problem Description:

  In the draft ANSI Common Lisp specification, the description of the
  accessor FILL-POINTER indicates an exceptional situation when the
  VECTOR argument is not a vector with a fill pointer, but no such
  situation is indicated when the NEW-FILL-POINTER argument is not a
  valid fill pointer.

Proposal:

  Add the following paragraph to the Exceptional Situations section of
  the dictionary entry for FILL-POINTER:

    Should signal an error of type TYPE-ERROR if NEW-FILL-POINTER is
    not a valid fill pointer for the VECTOR.

Test cases:

  (defun one ()
    (let ((v (make-array 10 :fill-pointer t)))
      (setf (fill-pointer v) -1)))

  (one) ; => [signals TYPE-ERROR with expected type (INTEGER 0 10)]

  (defun two ()
    (let ((v (make-array 10 :fill-pointer t)))
      (setf (fill-pointer v) 11)))

  (two) ; => [signals TYPE-ERROR with expected type (INTEGER 0 10)]

Rationale:

  We think it is a simple omission in the draft ANSI specification.

Current Practice:

Cost to Implementors:

  Very small.  We believe that most implementations are already
  signaling an error.  Some implementations may signal a simple error,
  and those implementations would need to signal a TYPE-ERROR instead.

Cost to Users:

  None.

Cost of non-adoption:

  Application programmers may need to add an explicit type check on
  the value of NEW-FILL-POINTER before calling (SETF FILL-POINTER)
  to be certain that their code is conforming.

Benefits:

  Application programmers may rely on an error being signaled, and
  thus avoid having to add explicit checks in portable code.

Aesthetics:

  No influence.

Discussion:

  TODO
